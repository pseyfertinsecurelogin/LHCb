
//-----------------------------------------------------------------------------
/** @file RichCommonBase.icpp
 *
 *  Implementation file for RICH base class : Rich::CommonBase
 *
 *  CVS Log :-
 *  $Id: RichCommonBase.icpp,v 1.16 2009-06-26 09:56:15 jonrob Exp $
 *
 *  @author Chris Jones    Christopher.Rob.Jones@cern.ch
 *  @date   2005-08-27
 */
//-----------------------------------------------------------------------------

// STL
#include <sstream>

// local
#include "RichKernel/RichCommonBase.h"

// Gaudi
#include "GaudiKernel/IJobOptionsSvc.h"

// Disable warning on windows
#ifdef _WIN32
#pragma warning ( disable:4661 ) // incomplete explicit templates
#endif

//=============================================================================
// Destructor
//=============================================================================
template <class PBASE>
Rich::CommonBase<PBASE>::~CommonBase() {}

//=============================================================================
// Initialisation
//=============================================================================
template <class PBASE>
StatusCode Rich::CommonBase<PBASE>::initialize()
{
  // Execute the base class initialize
  const StatusCode sc = PBASE::initialize();
  if ( sc.isFailure() )
  { return this -> Error( "Failed to initialise Gaudi Base class", sc ); }

  // Printout from initialize
  if ( this -> msgLevel(MSG::DEBUG) )
    this -> debug() << "Initialize" << endreq;

  return sc;
}
//=============================================================================

//=============================================================================
// Finalisation
//=============================================================================
template <class PBASE>
StatusCode Rich::CommonBase<PBASE>::finalize()
{
  // Printout from finalization
  if ( this -> msgLevel(MSG::DEBUG) )
    this -> debug() << "Finalize" << endreq;

  // Finalise base class and return
  return PBASE::finalize();
}
//=============================================================================

//=============================================================================
// Access job options service
//=============================================================================
template <class PBASE>
IJobOptionsSvc* Rich::CommonBase<PBASE>::joSvc() const
{
  if (!m_jos)
  { m_jos = this -> template svc<IJobOptionsSvc>( "JobOptionsSvc" ); }
  return m_jos;
}
//=============================================================================

//=============================================================================
// Sets Properties
//=============================================================================
template <class PBASE>
bool Rich::CommonBase<PBASE>::setProperties( const std::string & name ) const
{
  return ( my_setToolProperty<StringProperty> ( name , "Context"     ) &&
           my_setToolProperty<StringProperty> ( name , "OutputLevel" ) );
}
//=============================================================================

//=============================================================================
// set properties
//=============================================================================
template < class PBASE        >
template < class PROPERTYTYPE >
bool Rich::CommonBase<PBASE>::my_setToolProperty( const std::string & name,
                                                  const std::string & property ) const
{
  bool sc = true;

  // full tool name
  const std::string fullname = "ToolSvc." + name;

  // get properties for this tool name
  const PROPERTYTYPE * test_sp = my_getProperty<PROPERTYTYPE>( fullname, property );

  // If Context not set, set it
  if ( !test_sp )
  {

    // get Tool registry OutputLevel
    const PROPERTYTYPE * ts_sp = my_getProperty<PROPERTYTYPE>( this->toolRegistry()->name(), property );
    if ( ts_sp )
    {
      if ( this -> msgLevel(MSG::VERBOSE) )
      { this -> verbose() << "Setting " << *ts_sp << " for " << fullname << endreq; }
      sc = joSvc()->addPropertyToCatalogue(fullname,*ts_sp).isSuccess();
      if ( !sc ) { this -> Error( "Error setting "+property+" for " + fullname ).ignore(); }
    }
    else if ( this -> msgLevel(MSG::DEBUG) )
    {
      this -> debug() << this->toolRegistry()->name() << " has no " << property << endmsg;
    }

  } // tool already has property

  return sc;
}

//=============================================================================
// get properties
//=============================================================================
template < class PBASE        >
template < class PROPERTYTYPE >
const PROPERTYTYPE *
Rich::CommonBase<PBASE>::my_getProperty( const std::string & name,
                                         const std::string & property ) const
{
  // get properties for this name
  const PROPERTYTYPE * sp = NULL;
  const std::vector<const Property*> * properties = this -> joSvc()->getProperties( name );
  if ( properties )
  {
    if ( this -> msgLevel(MSG::VERBOSE) )
    { this -> verbose() << "Found " << properties->size() << " Properties for " << name << endmsg; }
    for ( std::vector<const Property*>::const_reverse_iterator itProp = properties->rbegin();
          itProp != properties->rend(); ++itProp )
    {
      if ( this -> msgLevel(MSG::VERBOSE) )
      { this->verbose() << " -> " << **itProp << endmsg; }
      if ( property == (*itProp)->name() )
      {
        sp = dynamic_cast<const PROPERTYTYPE*>(*itProp);
        if ( NULL != sp )
        {
          if ( this -> msgLevel(MSG::VERBOSE) )
          { this -> verbose() << "  -> Found requested property" << *sp << " for " << name << endreq; }
          break;
        }
        else
        {
          std::ostringstream mess;
          mess << "Property " + property + " has wrong type : Expected "
               << System::typeinfoName( typeid(PROPERTYTYPE) )
               << " Found "
               << System::typeinfoName( typeid(**itProp) );
          this -> Error( mess.str() ).ignore();
        }
      }
    }
  }
  return sp;
}
