#ifndef L0MUONKERNEL_CTRLFINALCNV_H
#define L0MUONKERNEL_CTRLFINALCNV_H 

/** @class CtrlCandCnv CtrlCandCnv.h  L0MuonKernel/CtrlCandCnv.h
 
  Class for constructing the raw data generated by the TELL1 linked to the processing boards in transparent mode. 

  @author
  @date

*/
#include "L0MuonKernel/CandRegisterHandler.h"
#include "L0MuonKernel/MuonCandidate.h"
#include <string>
#include <map>
#include <vector>
#include "L0MuonKernel/CtrlCandErrors.h"

namespace L0Muon {
  
  class CtrlCandCnv  {

  public:

    /// Default Constructor
    CtrlCandCnv();

    /// Default Constructor
    CtrlCandCnv(int side);

    /// Destructor
    ~CtrlCandCnv();
    
    LHCb::MuonTileID mid_BCSU(int iq, int ib);

    void release();

    std::vector<PMuonCandidate> muonCandidates();
    std::vector<PMuonCandidate> muonCandidates(int iq);
    std::vector<PMuonCandidate> muonCandidatesBCSU();
    std::vector<PMuonCandidate> muonCandidatesBCSU(int iq);
    std::vector<PMuonCandidate> muonCandidatesBCSU(int iq, int ib);

    int decodeBank(const std::vector<unsigned int> &raw, int version,int mode);
    int rawBank(std::vector<unsigned int> &raw, int ievt, int version, int mode, bool compression);

    // Obsolete versions only used in the simulation (before commissionning)
    int decodeBankDC06(const std::vector<unsigned int> &raw, int version);
    int rawBankDC06(std::vector<unsigned int> &raw);
    int decodeBankFinalCandidates(const std::vector<unsigned int> &raw, int version);
    int rawBankFinalCandidates(std::vector<unsigned int> &raw,  int ievt);
    int decodeBankBcsuCandidates(const std::vector<unsigned int> &raw, int version);
    int rawBankBcsuCandidates(std::vector<unsigned int> &raw);

    void dump(std::string tab="") {
      for (int i= 0; i<2; ++i) {
        m_candRegHandler[i].dump(-1,tab);
        for (int ib= 0; ib<12; ++ib) {
          m_candRegHandlerBCSU[i][ib].dump(-1,tab);
        } 
      }
    }

    int  ref_l0_B_Id(){return m_ref_l0_B_Id;}
    int  ref_l0EventNumber() {return m_ref_l0EventNumber;}
    void submitL0_B_Id(int l0_B_Id){ if (m_ref_l0_B_Id==-1) m_ref_l0_B_Id=l0_B_Id; }
    void submitL0EventNumber(int l0EventNumber){ if (m_ref_l0EventNumber==-1) m_ref_l0EventNumber=l0EventNumber; }
    void clearRef();
    
    const bool inError(int iq) const { return m_errors[iq].inError();}
    const bool inError(int iq, int ib)const { return m_errors[iq].inError(ib);}
    const int  decodingError(int iq) const { return int(m_errors[iq].decodingError());}
    const int  hardwareError(int iq) const {return m_errors[iq].hardwareError();}
    const int  hardwareError(int iq, int ib) const {return m_errors[iq].hardwareError(ib);}
    const int  statusError(int iq) const { return m_errors[iq].statusError();}
    const int  statusError(int iq,int ib) const { return m_errors[iq].statusError(ib);}
    const int  bcidError(int iq) const { return m_errors[iq].bcidError();}
    const int  bcidError(int iq,int ib) const { return m_errors[iq].bcidError(ib);}

    const CtrlCandErrors * errors(int iq) const {return &m_errors[iq];}
    
  private:
    int m_side;
    // Final candidates registers
    CandRegisterHandler m_candRegHandler[2];

    // BCSU candidates registers 
    CandRegisterHandler m_candRegHandlerBCSU[2][12];

    CtrlCandErrors m_errors[2];

    int m_ref_l0_B_Id;
    int m_ref_l0EventNumber;



  };
}; // namespace L0Muon
 
#endif    // L0MUONKERNEL_CTRLFINALCNV_H
