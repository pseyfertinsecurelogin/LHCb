// $Id: Trees.icpp,v 1.7 2009-05-06 20:20:01 ibelyaev Exp $
// ============================================================================
#ifndef LOKI_DECAYTREES_ICPP 
#define LOKI_DECAYTREES_ICPP 1
// ============================================================================
// Include files 
// ============================================================================
#include <limits>
// ============================================================================
/** @file
 *  The implementation file for the objects form the file Trees.h
 *  @author Vanya BELYAEV Ivan.Belyaev@nikhef.nl
 *  @date 2008-05-07
 */
// ============================================================================
// MARKED 
// ============================================================================
// constructor from the tree 
// ============================================================================
template <class PARTICLE>
inline Decays::Trees::Marked_<PARTICLE>::Marked_ 
( const Decays::iTree_<PARTICLE>& tree ) 
  : Decays::iTree_<PARTICLE>() 
  , m_tree     ( tree ) 
  , m_particle ( 0    ) 
{}
// ============================================================================
// copy constructor (ignore the marked particle)
// ============================================================================
template <class PARTICLE>
inline Decays::Trees::Marked_<PARTICLE>::Marked_ 
( const Decays::Trees::Marked_<PARTICLE>& right ) 
  : Decays::iTree_<PARTICLE> ( right ) 
  , m_tree ( right.m_tree ) 
  , m_particle ( 0 ) 
{}
// ============================================================================
// MANDATORY: the only one essential method:
// ============================================================================
template <class PARTICLE>
inline bool Decays::Trees::Marked_<PARTICLE>::operator() 
  ( typename Decays::iTree_<PARTICLE>::argument p ) const 
{
  /// reset the particle 
  m_particle = 0  ;
  const bool result = m_tree.tree ( p ) ;
  if ( result ) { m_particle = p ; }   // KEEP THE PARTICLE !!! 
  return result ;
}
// ============================================================================
// MANDATORY: the specific printout 
// ============================================================================
template <class PARTICLE>
inline std::ostream& 
Decays::Trees::Marked_<PARTICLE>::fillStream ( std::ostream& s ) const 
{ return s << " ^(" << m_tree << ")"; }
// ============================================================================
// Check the validity
// ============================================================================ 
template <class PARTICLE>
inline bool 
Decays::Trees::Marked_<PARTICLE>::valid() const 
{ return m_tree.tree().valid() ; }
// ============================================================================
// validate it
// ============================================================================
template <class PARTICLE>
inline StatusCode
Decays::Trees::Marked_<PARTICLE>::validate
( const LHCb::IParticlePropertySvc* svc ) const 
{ return m_tree.tree().validate ( svc ) ; }
// ============================================================================
// reset the collection cache 
// ============================================================================
template <class PARTICLE>
inline void 
Decays::Trees::Marked_<PARTICLE>::reset () const 
{
  // reset the own cache 
  m_particle = 0 ; 
  // reset the tree 
  m_tree.reset() ;
}
// ============================================================================
// collect the marked elements 
// ============================================================================
template <class PARTICLE>
inline size_t 
Decays::Trees::Marked_<PARTICLE>::collect 
( typename Decays::iTree_<PARTICLE>::Collection& output ) const 
{
  if ( 0 != m_particle ) 
  {
    output.push_back ( m_particle ) ; 
    return 1 + m_tree.collect ( output ) ;
  }
  return m_tree.collect ( output ) ;
}
// ============================================================================



// ============================================================================
// _Tree_
// ============================================================================
// the source of IDs
// ============================================================================
template <class PARTICLE>
inline size_t Decays::Trees::_Tree_<PARTICLE>::getID() 
{
  static size_t s_ID = 0 ;
  // reset it if it becomes too large: 
  if ( s_ID == std::numeric_limits<size_t>::max() ) { s_ID = 0 ; }
  return ++s_ID ;
}
// ============================================================================

// ============================================================================
// Op_
// ============================================================================
// constructor from two sub-trees 
// ============================================================================
template <class PARTICLE>
inline Decays::Trees::Op_<PARTICLE>::Op_ 
( const Decays::iTree_<PARTICLE>& n1 , 
  const Decays::iTree_<PARTICLE>& n2 ) 
  : Decays::iTree_<PARTICLE> () 
  , m_trees ()
{
  m_trees.push_back ( Decays::Trees::_Tree_<PARTICLE> ( n1 ) ) ;
  m_trees.push_back ( Decays::Trees::_Tree_<PARTICLE> ( n2 ) ) ;
}   
// ============================================================================
// constructor from list of sub-trees 
// ============================================================================
template <class PARTICLE>
inline Decays::Trees::Op_<PARTICLE>::Op_ 
( const typename Decays::Trees::Op_<PARTICLE>::SubTrees& trees ) 
  : Decays::iTree_<PARTICLE> () 
  , m_trees ( trees )
{}
// ============================================================================
// MANDATORY: check the validness 
// ============================================================================
template <class PARTICLE>
inline bool 
Decays::Trees::Op_<PARTICLE>::valid() const 
{ return !m_trees.empty() && Decays::valid ( m_trees.begin() , m_trees.end() ) ; }
// ============================================================================
// MANDATORY: the proper validation of the tree
// ============================================================================
template <class PARTICLE>
inline StatusCode 
Decays::Trees::Op_<PARTICLE>::validate 
( const LHCb::IParticlePropertySvc* svc ) const 
{
  if ( m_trees.empty() ) { return StatusCode::FAILURE ; }
  return Decays::validate ( m_trees.begin() , m_trees.end() , svc ) ;
}
// ============================================================================
// MANDATORY: reset method 
// ============================================================================
template <class PARTICLE>
inline void Decays::Trees::Op_<PARTICLE>::i_reset() const
{
  std::for_each 
    ( m_trees.begin () , 
      m_trees.end   () , 
      std::mem_fun_ref(&Decays::Trees::_Tree_<PARTICLE>::reset) );
}
// ============================================================================
// MANDATORY: collect all marked elements 
// ============================================================================
template <class PARTICLE>
inline size_t Decays::Trees::Op_<PARTICLE>::collect 
( typename Decays::iTree_<PARTICLE>::Collection& o ) const 
{
  size_t size = 0 ;
  for ( typename SubTrees::const_iterator it = m_trees.begin() ; 
        m_trees.end() != it ; ++it ) { size += it->collect ( o ) ; }
  return size ;
}
// ============================================================================
// has marked elements in the tree ? 
// ============================================================================
template <class PARTICLE>
inline bool Decays::Trees::Op_<PARTICLE>::marked() const 
{
  for ( typename SubTrees::const_iterator it = m_trees.begin() ; 
        m_trees.end() != it ; ++it ) { if ( it->marked() ) { return true ; } }  
  return false ;
}
// ============================================================================
// Or_
// ============================================================================
// constructor from two sub-trees 
// ============================================================================
template <class PARTICLE>
inline Decays::Trees::Or_<PARTICLE>::Or_ 
( const Decays::iTree_<PARTICLE>& n1 , 
  const Decays::iTree_<PARTICLE>& n2 ) 
  : Decays::Trees::Op_<PARTICLE> ( n1 , n2 )  
{}
// ============================================================================
// constructor from list of sub-trees 
// ============================================================================
template <class PARTICLE>
inline Decays::Trees::Or_<PARTICLE>::Or_ 
( const typename Decays::Trees::Op_<PARTICLE>::SubTrees& trees ) 
  : Decays::Trees::Op_<PARTICLE> ( trees )  
{}
// ============================================================================
// MANDATORY: the specific printout 
// ============================================================================
template <class PARTICLE>
inline std::ostream& 
Decays::Trees::Or_<PARTICLE>::fillStream( std::ostream& s ) const 
{
  s << " (";
  for ( typename Decays::Trees::Op_<PARTICLE>::SubTrees::const_iterator 
          tree = this->begin() ; this->end() != tree ; ++tree )
  { 
    if ( this->begin() != tree ) { s << "||" ; } 
    s << (*tree) ;
  }
  return s << ") " ;
}
// ============================================================================
// operator  |=
// ============================================================================
template <class PARTICLE>
inline 
Decays::Trees::Or_<PARTICLE>& 
Decays::Trees::Or_<PARTICLE>::operator|= 
( const Decays::Trees::Or_<PARTICLE>& tree ) 
{
  this->trees().insert ( this->end() , tree.begin() , tree.end() ) ;
  return  *this ;
}
// ============================================================================
// operator  ()
// ============================================================================
template <class PARTICLE>
inline bool 
Decays::Trees::Or_<PARTICLE>::operator()
  ( typename Decays::iTree_<PARTICLE>::argument p ) const 
{
  /// reset the components 
  this->i_reset () ;                                  // reset the components 
  return this->end() != std::find ( this->begin() , this->end() , p ) ;
}
// ============================================================================


// ============================================================================
// And_
// ============================================================================
// constructor from two sub-trees 
// ============================================================================
template <class PARTICLE>
inline Decays::Trees::And_<PARTICLE>::And_ 
( const Decays::iTree_<PARTICLE>& n1 , 
  const Decays::iTree_<PARTICLE>& n2 ) 
  : Decays::Trees::Op_<PARTICLE> ( n1 , n2 )  
{}
// ============================================================================
// constructor from list of sub-trees 
// ============================================================================
template <class PARTICLE>
inline Decays::Trees::And_<PARTICLE>::And_ 
( const typename Decays::Trees::Op_<PARTICLE>::SubTrees& trees ) 
  : Decays::Trees::Op_<PARTICLE> ( trees )  
{}
// ============================================================================
// MANDATORY: the specific printout 
// ============================================================================
template <class PARTICLE>
inline std::ostream& 
Decays::Trees::And_<PARTICLE>::fillStream( std::ostream& s ) const 
{
  s << " (";
  //
  for ( typename Decays::Trees::Op_<PARTICLE>::SubTrees::const_iterator tree 
          = this->begin() ; this->end() != tree ; ++tree )
  { 
    if ( this->begin() != tree ) { s << "&&" ; } 
    s << (*tree) ;
  }
  return s << ") " ;
}
// ============================================================================
// operator  &=
// ============================================================================
template <class PARTICLE>
inline 
Decays::Trees::And_<PARTICLE>& 
Decays::Trees::And_<PARTICLE>::operator&= 
( const Decays::Trees::And_<PARTICLE>& tree ) 
{
  this->trees().insert ( this->end() , tree.begin() , tree.end() ) ;
  return  *this ;
}
// ============================================================================
// operator  ()
// ============================================================================
template <class PARTICLE>
inline bool 
Decays::Trees::And_<PARTICLE>::operator()
  ( typename Decays::iTree_<PARTICLE>::argument p ) const 
{
  /// reset the components 
  this->i_reset () ;                                   // reset the components 
  // 
  for ( typename Decays::Trees::Op_<PARTICLE>::SubTrees::const_iterator it 
          = this->begin() ; this->end() != it ; ++it ) 
  { if ( (*it)!= p ) { return false ; } }                // RETURN 
  //                                                      
  return true ;                                          // RETURN 
}
// ============================================================================


// ============================================================================
// The END
// ============================================================================
#endif // LOKI_DECAYTREES_H
// ============================================================================
