// $Id: SVectorWithError.icpp,v 1.3 2009-09-12 19:29:26 ibelyaev Exp $
// ============================================================================
#ifndef LHCBMATH_SVECTORWITHERROR_ICPP 
#define LHCBMATH_SVECTORWITHERROR_ICPP 1
// ============================================================================
// Include files
// ============================================================================
// STD & STL 
// ============================================================================
#include <sstream>
#include <cmath>
// ============================================================================
// LHCbMath
// ============================================================================
#include "LHCbMath/SVectorWithError.h"
#include "LHCbMath/SymPosDefMatrixInverter.h"
#include "LHCbMath/MatrixInversion.h"
#include "LHCbMath/MatrixUtils.h"
// ============================================================================
/** @file 
 *  The implementation file for class Gaudi::Math::SVectorWithError
 *  @author Vanya BELYAEV Ivan.Belyaev@nikhef.nl
 *  @date 2009-06-13
 */
// ============================================================================
template <unsigned int N, class SCALAR>
inline double 
Gaudi::Math::SVectorWithError<N,SCALAR>::chi2 
( const Gaudi::Math::SVectorWithError<N,SCALAR>& right ) const
{
  Covariance s_cov2 ( this->cov2() ) ;
  s_cov2 += right.cov2() ;
  /// use Manuel's inverter:
  const bool ok = Gaudi::Math::invertPosDefSymMatrix ( s_cov2 ) ;
  if  ( !ok ) { return -1 ; }                                        // RETURN  
  /// calculate chi2 
  return ROOT::Math::Similarity ( value() - right.value() , s_cov2 ) ;
}
// ============================================================================
template <unsigned int N, class SCALAR>
inline double 
Gaudi::Math::SVectorWithError<N,SCALAR>::chi2 
( const ROOT::Math::SVector<SCALAR,N>& right ) const
{
  Covariance s_cov2 ( this->cov2() ) ;
  /// use Manuel's inverter:
  const bool ok = Gaudi::Math::invertPosDefSymMatrix ( s_cov2 ) ;
  if  ( !ok ) { return -1 ; }                                        // RETURN  
  /// calculate chi2 
  return ROOT::Math::Similarity ( value() - right , s_cov2 ) ;
}
// ============================================================================
template <unsigned int N, class SCALAR>
template <class B>
inline double 
Gaudi::Math::SVectorWithError<N,SCALAR>::chi2 
( const ROOT::Math::VecExpr<B,SCALAR,N>& right ) const
{
  Covariance s_cov2 ( this->cov2() ) ;
  /// use Manuel's inverter:
  const bool ok = Gaudi::Math::invertPosDefSymMatrix ( s_cov2 ) ;
  if  ( !ok ) { return -1 ; }                                        // RETURN  
  /// calculate chi2 
  return ROOT::Math::Similarity ( value() - right , s_cov2 ) ;
}
// ============================================================================
template <unsigned int N, class SCALAR>
inline
Gaudi::Math::SVectorWithError<N,SCALAR> 
Gaudi::Math::SVectorWithError<N,SCALAR>::__add__  
( const Gaudi::Math::SVectorWithError<N,SCALAR>& right  ) const 
{ return ( (*this) + right ) ; }
// ============================================================================
template <unsigned int N, class SCALAR>
inline
Gaudi::Math::SVectorWithError<N,SCALAR> 
Gaudi::Math::SVectorWithError<N,SCALAR>::__sub__  
( const Gaudi::Math::SVectorWithError<N,SCALAR>& right  ) const 
{ return ( (*this) - right ) ; }
// ============================================================================
template <unsigned int N, class SCALAR>
inline
Gaudi::Math::SVectorWithError<N,SCALAR> 
Gaudi::Math::SVectorWithError<N,SCALAR>::__add__  
( const ROOT::Math::SVector<SCALAR,N>& right  ) const 
{ return ( (*this) + right ) ; }
// ============================================================================
template <unsigned int N, class SCALAR>
inline
Gaudi::Math::SVectorWithError<N,SCALAR> 
Gaudi::Math::SVectorWithError<N,SCALAR>::__sub__  
( const ROOT::Math::SVector<SCALAR,N>& right  ) const 
{ return ( (*this) - right ) ; }
// ============================================================================
template <unsigned int N, class SCALAR>
inline
Gaudi::Math::SVectorWithError<N,SCALAR> 
Gaudi::Math::SVectorWithError<N,SCALAR>::__radd__  
( const ROOT::Math::SVector<SCALAR,N>& right  ) const 
{ return ( (*this) + right ) ; }
// ============================================================================
template <unsigned int N, class SCALAR>
inline
Gaudi::Math::SVectorWithError<N,SCALAR> 
Gaudi::Math::SVectorWithError<N,SCALAR>::__rsub__  
( const ROOT::Math::SVector<SCALAR,N>& right  ) const 
{ return ( right - (*this) ) ; }
// ============================================================================
// conversion to string
// ============================================================================
template <unsigned int N, class SCALAR>
inline std::string  
Gaudi::Math::SVectorWithError<N,SCALAR>::toString   () const // conversion to string
{
  std::ostringstream os ;
  this->fillStream ( os ) ;
  return os.str() ;
}
// ============================================================================
// printout 
// ============================================================================
template <unsigned int N, class SCALAR>
inline std::ostream& 
Gaudi::Math::SVectorWithError<N,SCALAR>::fillStream ( std::ostream& s ) const 
{
  s << "( " ;
  for ( unsigned int i = 0 ; i < N ; ++i ) 
  {
    if ( 0 != i ) { s << " , " ; }
    s << value()(i) << " +- " ;
    const double d = m_cov2(i,i) ;
    s <<  ( 0 <= d ? std::sqrt ( d ) : -std::sqrt(-d) ) ;
  }
  return s << " )" ;
} 
// ============================================================================
/*  get the correlation coefficient between "i" and "j"
 *  for invalid setup , return large negative value 
 *  @param i the first index 
 *  @param j the second index 
 *  @return correlation coefficient 
 */
// ============================================================================
template <unsigned int N, class SCALAR>
inline SCALAR Gaudi::Math::SVectorWithError<N,SCALAR>::corr 
( unsigned int i , 
  unsigned int j ) const 
{
  static const SCALAR s_bad = -10000 ;
  //
  const SCALAR sii = cov2( i , i ) ;
  const SCALAR sjj = cov2( j , j ) ;
  //
  if ( 0 >= sii || 0 >= sjj ) { return s_bad ; }                      // RETURN  
  //
  return cov2( i , j ) / std::sqrt ( sii * sjj ) ;                    // RETURN 
}
// ============================================================================
/*  get the full correlation matrix 
 *  @return false for invalid setup 
 */
// ============================================================================
template <unsigned int N, class SCALAR>
inline bool Gaudi::Math::SVectorWithError<N,SCALAR>::corr 
( typename Gaudi::Math::SVectorWithError<N,SCALAR>::Covariance& corrm ) const
{
  bool OK = true ;
  //
  for ( unsigned int i = 0 ; i < N && OK ; ++i ) 
  {
    corrm ( i , i ) = 1 ;
    //
    const SCALAR sii = cov2 ( i , i ) ;
    if   ( 0 >= sii ) { OK = false ; break ; }                       // BREAK
    //
    for ( unsigned int j =  i + 1 ; j < N && OK ; ++j ) 
    {
      const SCALAR sjj = cov2 ( j , j ) ;
      if ( 0 >= sjj ) { OK = false ; break ; }                        // BREAK
      //
      corrm ( i , j ) = cov2 (i , j ) / std::sqrt ( sii * sjj ) ;   
      //
    }
  }
  //
  if ( !OK ) { Gaudi::Math::setToUnit ( corrm , -1. ) ; }
  //
  return OK ;
}
// ============================================================================
// The END 
// ============================================================================
#endif // LHCBMATH_SVECTORWITHERROR_ICPP 
// ============================================================================
