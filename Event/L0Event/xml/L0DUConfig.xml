<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE gdd SYSTEM "gdd.dtd">
<gdd>
  <package name="L0Event">

    
    <class 
      author="Olivier Deschamps"
      desc="This class represents the keyed L0DU Configuration"
      name="L0DUConfig"
      serializers="FALSE">
      <base   name = "KeyedObject&lt;long&gt;" />
      &KeyedObject;

      <location name = "Default"   place = "Trig/L0/L0DUConfig"  />
      <location name = "Emulated"  place = "Emu/L0/L0DUConfig"  />


      <import name="Event/L0DUElementaryData"/>
      <import name="Event/L0DUElementaryCondition"/>
      <import name="Event/L0DUChannel"/>
      <import name="Event/L0DUTrigger"/>
      <import name="string" std="TRUE"/>

      <typedef
        def    = "Base"
        type   = "KeyedObject&lt;long&gt;"
        desc   = "L0DU Trigger Configuration Key"
        access = "PROTECTED"
        />


      <constructor
        desc     = "Default constructor"
        initList = "Base ( 0x0000   )  , m_definition(),m_data(),m_conditions(),m_channels(),m_triggers()"
        > <code/></constructor>

      <constructor
        desc     = "non-default constructor"
        argList  = "long tck "
        initList = "Base ( tck ) , m_definition(),m_data(),m_conditions(),m_channels(),m_triggers()"
        > <code/> </constructor>


      <constructor 
        desc     = "Copy Constructor" 
        argList  = "LHCb::L0DUConfig rh"
        initList = "Base(rh.key() ), m_definition(rh.definition() ), m_data(rh.data() ), m_conditions (rh.conditions() )
        , m_channels(rh.channels() ),m_triggers(rh.triggers() )"
        > <code/> </constructor>


      <attribute name = "definition" desc = " L0DU Channel key definition"  type = "std::string"/>
      <attribute name = "data" desc = " L0DU Elementary condition" type = "LHCb::L0DUElementaryData::Map" nonconstaccessor='TRUE' />
      <attribute name = "conditions" desc = " L0DU Elementary condition" type = "LHCb::L0DUElementaryCondition::Map"  nonconstaccessor='TRUE'/>
      <attribute name = "channels" desc = " L0DU channels" type = "LHCb::L0DUChannel::Map"  nonconstaccessor='TRUE'/>      
      <attribute name = "triggers" desc = "Set of L0DU channels" type = "LHCb::L0DUTrigger::Map"  nonconstaccessor='TRUE'/>      

      <method desc   = "return Trigger Configuration Key @alias of key() " name   = "tck" type   = "long" const = 'TRUE'><code>return key();</code></method>
      <method desc   = "delete MAPs content" name="release" type="void">
        <code>
          for(LHCb::L0DUTrigger::Map::iterator ic = m_triggers.begin();ic!=m_triggers.end();++ic){
          if( NULL != (*ic).second)delete (*ic).second;
          }
          m_triggers.clear();

          for(LHCb::L0DUChannel::Map::iterator ic = m_channels.begin();ic!=m_channels.end();++ic){
           if( NULL != (*ic).second)delete (*ic).second;
          }
          m_channels.clear();
          for(LHCb::L0DUElementaryCondition::Map::iterator ic = m_conditions.begin();ic!=m_conditions.end();++ic){
           if( NULL != (*ic).second)delete (*ic).second;
          }
          m_conditions.clear();
          for(LHCb::L0DUElementaryData::Map::iterator ic = m_data.begin();ic!=m_data.end();++ic){
           if( NULL != (*ic).second)delete (*ic).second;
          }
          m_data.clear();

        </code>
      </method>


      <method name  = "description" desc = "L0DUConfig  short description" type  = "std::string" > </method>
      <method name  = "summary" desc = "L0DUConfig full summary after processing" type  = "std::string" > </method>


      <method name  = "resetChannelCounters" desc = "reset all channel counters" type  = "void" >
        <code>
          for(LHCb::L0DUChannel::Map::iterator it = m_channels.begin();it!=m_channels.end();it++){
          ((*it).second)->setCounter(0);
          }
        </code>
      </method>

      <method name  = "incrementCounters" desc = "increment all channels counter" type  = "void" >
        <code>
          for(LHCb::L0DUChannel::Map::iterator it = m_channels.begin();it!=m_channels.end();it++){
          unsigned int count = ((*it).second)->counter() + ((*it).second)->rate();
          if(count &gt;=  LHCb::L0DUCounter::Scale)count -= LHCb::L0DUCounter::Scale;
          ((*it).second)->setCounter(count);
          }
        </code>
      </method>
      <method name  = "decrementCounters" desc = "decrement all channels counter" type  = "void" >
        <code>
          for(LHCb::L0DUChannel::Map::iterator it = m_channels.begin();it!=m_channels.end();it++){
          int count = ((*it).second)->counter() - ((*it).second)->rate();
          if(count &lt; 0 )count += LHCb::L0DUCounter::Scale;
          ((*it).second)->setCounter(count);
          }
        </code>
      </method>

      <method name  = "resetEmulated" desc = "reset all channels emulation flags" type  = "void" argList="bool value=false" >
        <code>
          for(LHCb::L0DUChannel::Map::iterator it = m_channels.begin();it!=m_channels.end();it++){
          ((*it).second)->setEmulated(value);
          }
        </code>
      </method>

      <method name  = "emulated" desc = "return true when all channels are emulated" type  = "bool" >
        <code>
          for(LHCb::L0DUChannel::Map::iterator it = m_channels.begin();it!=m_channels.end();it++){
          if( !((*it).second)->emulated() )return false;
          }
          return true;
        </code>
      </method>

      <method name  = "clearDataValue" desc = "clear all ElementaryData operands" type  = "void" >
        <code>
          for(LHCb::L0DUElementaryData::Map::iterator it = m_data.begin();it!=m_data.end();it++){
          if( ((*it).second)->type() == L0DUElementaryData::Constant)continue;
          ((*it).second)->operands().clear();
          }
          resetEmulated();
        </code>
      </method>

      <method name  = "emulate" desc = "emulate all channels" type  = "LHCb::L0DUConfig*" >
        <code>
          for(LHCb::L0DUChannel::Map::iterator it = m_channels.begin();it!=m_channels.end();it++){
	    ((*it).second)->emulate();
          }
	  return this;
        </code>
      </method>


      <method name  = "emulatedDecision" desc = "global emulated decision (incl. downscaling)" type  = "bool" >
        <code>
          for(LHCb::L0DUChannel::Map::iterator it = m_channels.begin();it!=m_channels.end();it++){
           LHCb::L0DUChannel* channel = (*it).second;
           if( channel->emulatedDecision() &amp;&amp; channel->enable() )return true;
          }
	  return false;
        </code>
      </method>


      <method name  = "emulatedPreDecision" desc = "global emulated decision (without downscaling)" type  = "bool" >
        <code>
          for(LHCb::L0DUChannel::Map::iterator it = m_channels.begin();it!=m_channels.end();it++){
           LHCb::L0DUChannel* channel = (*it).second;
           if( channel->emulatedPreDecision() &amp;&amp; channel->enable() )return true;
          }
	  return false;
        </code>
      </method>

      <method name  = "isDownscaled" desc = "return true if the L0 decision would be yes without any downscaling" type  = "bool" >
        <code>
          return (emulatedPreDecision() == emulatedDecision() );
        </code>
      </method>



      <method
        name="triggerByChannelName" 
        argList="std::string name"
        desc="return the  trigger(s) the channel belongs to"
        type="std::vector&lt;std::string&gt;" 
        const="TRUE">
        <code> 
          std::vector&lt;std::string&gt; list;
          for(LHCb::L0DUTrigger::Map::const_iterator it = m_triggers.begin();it!=m_triggers.end();++it){
          std::string trigName = (*it).first;
          LHCb::L0DUChannel::Map channels = (*it).second-&gt;channels();
          for(LHCb::L0DUChannel::Map::iterator ic = channels.begin() ; ic != channels.end() ; ++ic){
          if( (*ic).second->name() == name){
          list.push_back(trigName);
          continue;
          }
          }
          }
         return list;
        </code>
      </method>



    </class>
  </package>
</gdd>



