<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE gdd SYSTEM "gdd.dtd">
<gdd>
  <package name="L0Event">



    <namespace
      desc="L0DU template configuration attributes"
      name="L0DUTemplateConfig"
      author="O. Deschamps">
      <attribute
        desc="default name of the Template configuration" 
        name="Name" 
        type="static const std::string" 
        init='"Template"'/>
      <attribute
        desc="fake TCK value of the Template configuration" 
        name="TCKValue" 
        type="static const long" 
        init="0x10000"/>
    </namespace>
    
    <class
     author="Olivier Deschamps"
     desc="This class represents the keyed L0DU Configuration"
     name="L0DUConfig">
      <base   name = "KeyedObject&lt;unsigned int&gt;" />
      &KeyedObject;
      
      <location name = "Default"   place = "Trig/L0/L0DUConfig"  />
      <location name = "Emulated"  place = "Emu/L0/L0DUConfig"  />
      
      
      <import name="Event/L0DUElementaryData"/>
      <import name="Event/L0DUElementaryCondition"/>
      <import name="Event/L0DUChannel"/>
      <import name="Event/L0DUTrigger"/>
      <import name="Event/L0DUTemplateConfig"/> 
      <import name="string" std="TRUE"/>

      <typedef
        def    = "Base"
        type   = "KeyedObject&lt;unsigned int&gt;"
        desc   = "L0DU Trigger Configuration Key"
        access = "PROTECTED"
        />


      <constructor
        desc     = "Default constructor"
        initList = "Base ( 0x0000   ), m_recipe(), m_definition(),m_data(),m_conditions(),m_channels(),m_triggers(),m_completed(false)"
        > <code/></constructor>

      <constructor
        desc     = "non-default constructor"
        argList  = "unsigned int tck "
        initList = "Base ( tck ), m_recipe(), m_definition(),m_data(),m_conditions(),m_channels(),m_triggers(),m_completed(false)"
        > <code/> </constructor>


      <constructor 
        desc     = "Copy Constructor" 
        argList  = "LHCb::L0DUConfig rh"
        initList = "Base(rh.key() ), m_recipe(rh.recipe()),m_definition(rh.definition() ), m_data(rh.data() ), m_conditions (rh.conditions() ), m_channels(rh.channels() ),m_triggers(rh.triggers()),m_completed(rh.completed()) "
        > <code/> </constructor>


      <attribute name = "recipe" desc = " L0DU Channel recipe name"  type = "std::string"/>
      <attribute name = "definition" desc = " L0DU Channel key definition"  type = "std::string"/>
      <attribute name = "data" desc = " L0DU Elementary condition" type = "LHCb::L0DUElementaryData::Map" nonconstaccessor='TRUE' />
      <attribute name = "conditions" desc = " L0DU Elementary condition" type = "LHCb::L0DUElementaryCondition::Map"  nonconstaccessor='TRUE'/>
      <attribute name = "channels" desc = " L0DU channels" type = "LHCb::L0DUChannel::Map"  nonconstaccessor='TRUE'/>      
      <attribute name = "triggers" desc = "Set of L0DU channels" type = "LHCb::L0DUTrigger::Map"  nonconstaccessor='TRUE'/>      
      <attribute name = "completed" desc = "Complete Configuration (i.e. contain Processor Data Value -> ready for emulation)" type = "bool"  nonconstaccessor='TRUE'/>      



      <method desc   = "return Trigger Configuration Key @alias of key() " name   = "tck" type   = "unsigned int" const = 'TRUE'><code>return key();</code></method>
      <method desc   = "delete MAPs content" name="release" type="void">
        <code>
          for(LHCb::L0DUTrigger::Map::iterator ic = m_triggers.begin();ic!=m_triggers.end();++ic){
          if( NULL != (*ic).second)delete (*ic).second;
          }
          m_triggers.clear();

          for(LHCb::L0DUChannel::Map::iterator ic = m_channels.begin();ic!=m_channels.end();++ic){
           if( NULL != (*ic).second)delete (*ic).second;
          }
          m_channels.clear();
          for(LHCb::L0DUElementaryCondition::Map::iterator ic = m_conditions.begin();ic!=m_conditions.end();++ic){
           if( NULL != (*ic).second)delete (*ic).second;
          }
          m_conditions.clear();
          for(LHCb::L0DUElementaryData::Map::iterator ic = m_data.begin();ic!=m_data.end();++ic){
           if( NULL != (*ic).second)delete (*ic).second;
          }
          m_data.clear();

        </code>
      </method>


      <method name  = "description" desc = "L0DUConfig  short description" type  = "std::string" > </method>
      <method name  = "summary" desc = "L0DUConfig full summary after processing" type  = "std::string" > </method>



      <method name  = "numberOfChannels" 
	      desc = "Count the number channels with a given decisionType (default ANY)" 
	      type  = "int" 
	      argList="int mask=L0DUDecision::Any"
              const="TRUE">
        <code>
	  int k = 0; 
          for(LHCb::L0DUChannel::Map::const_iterator it = m_channels.begin();it!=m_channels.end();it++){
	  const LHCb::L0DUChannel* channel = (*it).second;
          if( mask == 0 &amp;&amp; channel->decisionType() == 0)k++;
	  else if( ( channel->decisionType() &amp; mask ) == 0)continue;
	  else k++;
          }
	  return k;
        </code>
      </method>
      <method name  = "numberOfTriggers" 
	      desc = "Count the number trigger with a given decisionType (default ANY)" 
	      type  = "int" 
	      argList="int mask=L0DUDecision::Any"
              const="TRUE">
        <code>
	  int k = 0; 
          for(LHCb::L0DUTrigger::Map::const_iterator it = m_triggers.begin();it!=m_triggers.end();it++){
	  const LHCb::L0DUTrigger* trigger = (*it).second;
          if( mask == 0 &amp;&amp; trigger->decisionType() == 0)k++;          
	  else if( ( trigger->decisionType() &amp; mask ) == 0 )continue;
	  else k++;
          }
	  return k;
        </code>
      </method>



      <method name  = "updateCounters" argList="bool update=true" desc = "enable/disable all the channels downscaling counters" type  = "void" >
        <code>
          for(LHCb::L0DUChannel::Map::iterator it = m_channels.begin();it!=m_channels.end();it++){
          ((*it).second)->setUpdateCounter(update);
          }
        </code>
      </method>

      <method name  = "resetChannelCounters" desc = "reset all channel counters" type  = "void" >
        <code>
          for(LHCb::L0DUChannel::Map::iterator it = m_channels.begin();it!=m_channels.end();it++){
          ((*it).second)->setCounter(0);
          }
        </code>
      </method>

      <method name  = "incrementCounters" desc = "increment all channels counter" type  = "void" >
        <code>
          for(LHCb::L0DUChannel::Map::iterator it = m_channels.begin();it!=m_channels.end();it++){
          unsigned int count = ((*it).second)->counter() + ((*it).second)->rate();
          if(count &gt;=  LHCb::L0DUCounter::Scale)count -= LHCb::L0DUCounter::Scale;
          ((*it).second)->setCounter(count);
          }
        </code>
      </method>
      <method name  = "decrementCounters" desc = "decrement all channels counter" type  = "void" >
        <code>
          for(LHCb::L0DUChannel::Map::iterator it = m_channels.begin();it!=m_channels.end();it++){
          int count = ((*it).second)->counter() - ((*it).second)->rate();
          if(count &lt; 0 )count += LHCb::L0DUCounter::Scale;
          ((*it).second)->setCounter(count);
          }
        </code>
      </method>

      <method name  = "resetEmulated" desc = "reset all channels emulation flags" type  = "void" argList="bool value=false" >
        <code>
          for(LHCb::L0DUChannel::Map::iterator it = m_channels.begin();it!=m_channels.end();it++){
          ((*it).second)->setEmulated(value);
          }
        </code>
      </method>

      <method name  = "emulated" desc = "return true when all channels are emulated" type  = "bool"         const="TRUE">
        <code>
          for(LHCb::L0DUChannel::Map::const_iterator it = m_channels.begin();it!=m_channels.end();it++){
          if( !((*it).second)->emulated() )return false;
          }
          return true;
        </code>
      </method>

      <method name  = "clearDataValue" desc = "clear all ElementaryData operands" type  = "void" >
        <code>
          for(LHCb::L0DUElementaryData::Map::iterator it = m_data.begin();it!=m_data.end();it++){
          if( ((*it).second)->type() == L0DUElementaryData::Constant)continue;
          ((*it).second)->operands().clear();
          }
          resetEmulated();
        </code>
      </method>

      <method name  = "emulate" desc = "emulate all channels" type  = "LHCb::L0DUConfig*" >
        <code>
          for(LHCb::L0DUChannel::Map::iterator it = m_channels.begin();it!=m_channels.end();it++){
	    ((*it).second)->emulate();
          }
	  return this;
        </code>
      </method>


      <method name  = "emulatedDecision" 
              desc = "global emulated decision (incl. downscaling) for a given decision" 
              type  = "bool" 
              argList = "int mask=L0DUDecision::Physics"
              const="TRUE">
        <code>
          return ( emulatedDecisionValue() &amp; mask) != 0;
         </code>
      </method>


      <method name  = "emulatedDecisionValue" 
              desc = "global emulated decision (incl. downscaling)" 
              type  = "int" 
              const="TRUE">
        <code>
          int value = 0;
          for(LHCb::L0DUChannel::Map::const_iterator it = m_channels.begin();it!=m_channels.end();it++){
           LHCb::L0DUChannel* channel = (*it).second;
           if( channel->emulatedDecision() )value |= channel->decisionType();
          }
	  return value;
         </code>
      </method>


      <method name  = "emulatedPreDecision" 
              desc = "global emulated decision (without downscaling)" 
              type  = "bool"
              argList = "int mask=L0DUDecision::Physics" 
              const="TRUE">
        <code>
          return (emulatedPreDecisionValue() &amp; mask) != 0;
         </code>
      </method>



      <method name  = "emulatedPreDecisionValue" desc = "global emulated decision (without downscaling)" type  = "int"               const="TRUE">
        <code>
          int value = 0;
          for(LHCb::L0DUChannel::Map::const_iterator it = m_channels.begin();it!=m_channels.end();it++){
           LHCb::L0DUChannel* channel = (*it).second;
           if( channel->emulatedPreDecision() ) value |=  channel->decisionType();
          }
	  return value;
        </code>
      </method>

      <method name  = "isDownscaled" desc = "return the downscaling decision as (emulatedDecision == emulatedPreDecision)" type  = "bool"  const="TRUE">
        <code>
          return (emulatedPreDecisionValue() == emulatedDecisionValue() );
        </code>
      </method>



      <method
        name="triggerByChannelName" 
        argList="std::string name"
        desc="return the  trigger(s) the channel belongs to"
        type="std::vector&lt;std::string&gt;" 
        const="TRUE">
        <code> 
          std::vector&lt;std::string&gt; list;
          for(LHCb::L0DUTrigger::Map::const_iterator it = m_triggers.begin();it!=m_triggers.end();++it){
          std::string trigName = (*it).first;
          const LHCb::L0DUChannel::Map&amp; channels = (*it).second-&gt;channels();
          for(LHCb::L0DUChannel::Map::const_iterator ic = channels.begin() ; ic != channels.end() ; ++ic){
          if( (*ic).second->name() == name){
          list.push_back(trigName);
          continue;
          }
          }
          }
         return list;
        </code>
      </method>



    </class>
  </package>
</gdd>



