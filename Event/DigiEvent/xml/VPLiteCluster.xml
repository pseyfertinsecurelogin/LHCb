<?xml version="1.0" encoding="ISO-8859-1"?>
<!--- $Id: -->
<!--- Author  : Victor Coco Victor.Coco@cern.ch-->
<!--- Created : 2009-11-13 -->
<!DOCTYPE gdd SYSTEM "gdd.dtd">
<gdd>

<!--- IF YOU PLAN TO MODIFY THE BITFIELD, PLEASE READ CAREFULLY THE FINAL COMMENT -->

<package name="DigiEvent">
    <class name="VPLiteCluster" 
     author="V. Coco" 
     desc="A cluster as might be produced by the TELL40 but without the full information"
     location="Raw/VP/LiteClusters"
     serializers="FALSE"
    >

    <import name="Kernel/VPChannelID"/>
    <import name="Kernel/FastClusterContainer"/>
    <import name="Kernel/SiDataFunctor"/>
    <import name="LHCbMath/LHCbMath"/>
 
    <typedef desc = "channelID type"
       type =  "LHCb::VPChannelID"
       def = "chan_type"
       access = "PUBLIC " />

    <typedef desc = "fast container for light clusters"
       type =  "FastClusterContainer &lt; LHCb::VPLiteCluster, ulonglong &gt;"
       def = "VPLiteClusters"
       access = "PUBLIC " />


     <typedef desc = "finding policy"
       type =  "SiDataFunctor::CompareByChannel &lt; LHCb::VPLiteCluster&gt;"
       def = "findPolicy"
       access = "PUBLIC " /> 

     <constructor desc="Constructor" 
       argList='VPChannelID &amp; chan,  unsigned int ToT , std::pair&lt;double,double&gt; fracPix, bool longPix'>
       <code>

 unsigned int tFracX = (LHCb::Math::round(fracPix.first * (1 &lt;&lt;( interPixelFractionYBits-interPixelFractionXBits))));
 unsigned int tFracY = (LHCb::Math::round(fracPix.second *(1 &lt;&lt; (interPixelFractionYBits-interPixelFractionXBits))));
 unsigned int tlongPix;
 longPix == true  ? tlongPix = 1:   tlongPix= 0;

 m_liteCluster = (((ulonglong)chan) &lt;&lt; channelIDBits) + 
                 (((ulonglong)ToT) &lt;&lt; clustToTBits) +
                 (((ulonglong)tFracX) &lt;&lt; interPixelFractionXBits) +
                 (((ulonglong)tFracY) &lt;&lt; interPixelFractionYBits) +
                 (((ulonglong)tlongPix) &lt;&lt; longPixBits)
                 ;
       </code>
      </constructor>


    <constructor desc="Constructor" 
       argList='VPChannelID &amp; chan ,unsigned int ToT,
                std::pair&lt;unsigned int,unsigned int&gt; fracPixel, bool longPix'>
       <code>

 unsigned int tlongPix;
 longPix == true  ? tlongPix = 1:   tlongPix= 0;
 m_liteCluster = (((ulonglong)chan) &lt;&lt; channelIDBits) +
                 (((ulonglong)ToT) &lt;&lt; clustToTBits) +
                 (((ulonglong)fracPixel.first) &lt;&lt; interPixelFractionXBits) +
                 (((ulonglong)fracPixel.second) &lt;&lt; interPixelFractionYBits) +
                 (((ulonglong)tlongPix) &lt;&lt; longPixBits)
          ;
       </code>
      </constructor>



     <destructor  desc="destructor">
     <code>
     //
     </code>
     </destructor>

     <method type='LHCb::VPLiteCluster &amp;' 
             name='operator ='
             argList='const VPLiteCluster &amp; c'  
             const='FALSE'  desc='equal'>
        <code>m_liteCluster = c.m_liteCluster; 
              return *this; </code>
     </method>

     <method
      name="interPixelFraction"
      type="std::pair&lt;double,double&gt;"
      desc="fractionnal positions within a pixel"
      const="TRUE">
     <code>
 std::pair&lt;unsigned int,unsigned int&gt; fracUnit = fractionUnits();
 std::pair&lt;double,double&gt; frac(double(fracUnit.first)/double((1 &lt;&lt; (interPixelFractionYBits-interPixelFractionXBits))),
  double(fracUnit.second)/double((1 &lt;&lt;(interPixelFractionYBits-interPixelFractionXBits) )));
 return frac;
     </code>
     </method>


     <method
      name="interPixelFractionX"
      type="double"
      desc="fractionnal X position within a pixel"
      const="TRUE">
     <code>
return  double(fractionUnitsX())/double((1 &lt;&lt;( interPixelFractionYBits-interPixelFractionXBits)));
     </code>
     </method>

     <method
      name="clustToT"
      type="unsigned int"
      desc="clustToT of the cluster"
      const="TRUE">
     <code>
return (unsigned int)((m_liteCluster &amp;0x70000000LL ) &gt;&gt; clustToTBits );
     </code>
     </method>


     <method
      name="interPixelFractionY"
      type="double"
      desc="fractionnal Y position within a pixel"
      const="TRUE">
     <code>
return  double(fractionUnitsY())/double((1 &lt;&lt;( interPixelFractionYBits-interPixelFractionXBits)));
     </code>
     </method>


     <method
      name="isLongPixel"
      type="bool"
      desc="is it an long pixel"
      const="TRUE">
     <code>
  return (((m_liteCluster &amp; (ulonglong)0x80000000LL) &gt;&gt; longPixBits) == 1);
     </code>
     </method>

      <method
      access="PRIVATE"
      name="fractionUnits"
      type="std::pair&lt;unsigned int,unsigned int&gt;"
      desc="pair of numbers between 0 and  /8ths of the x and y size of a pixel"
      const="TRUE"
      >
      <code> 
std::pair&lt;unsigned int,unsigned int&gt; fracUnit ((unsigned int)((m_liteCluster &amp; (ulonglong)0x700000000LL) &gt;&gt; interPixelFractionXBits),(unsigned int)((m_liteCluster &amp; (ulonglong)0x3800000000LL) &gt;&gt; interPixelFractionYBits)); 
return fracUnit;
     </code>
     </method>

      <method
      access="PRIVATE"
      name="fractionUnitsX"
      type="unsigned int"
      desc="number between 0 and  /8ths of the x size of a pixel"
      const="TRUE"
      >
      <code> 

return (unsigned int)((m_liteCluster &amp; (ulonglong)0x700000000LL) &gt;&gt; interPixelFractionXBits);
     </code>
     </method>

      <method
      access="PRIVATE"
      name="fractionUnitsY"
      type="unsigned int"
      desc="number between 0 and  /8ths of the y size of a pixel"
      const="TRUE"
      >
      <code> 

return (unsigned int)((m_liteCluster &amp; (ulonglong)0x3800000000LL) &gt;&gt; interPixelFractionYBits);
     </code>
     </method>

      <method
      access="PUBLIC"
      name="channelID"
      type="LHCb::VPChannelID"
      desc="The Channel"
      const="TRUE"
      >
      <code> return VPChannelID((unsigned int)((m_liteCluster &amp; 0xfffffffLL) &gt;&gt; channelIDBits)); 
     </code>
     </method>


     <attribute type='ulonglong' name='liteCluster' setMeth="FALSE" getMeth="FALSE" desc='the lite Cluster' init='0x0LL'/>

     <enum name='liteClusterBits' desc='position of the first bit of a given field'>
       <enumval name = 'channelIDBits' value = '0' desc='the channelID field 1st bit position'/>
       <enumval name = 'clustToTBits' value = '28' desc='the clustToT field 1st bit position'/>
       <enumval name = 'longPixBits' value = '31' desc='the longPix field 1st bit position'/>
       <enumval name = 'interPixelFractionXBits' value = '32' desc='the interPixelFractionX field 1st bit position'/>
       <enumval name = 'interPixelFractionYBits' value = '35' desc='the interPixelFractionY field 1st bit position'/>
     </enum>  

<!--- First attempt was using enum also for filed mask, BUT this creates some warning (and probably errors) under win32 -->
<!--- Since it does not recognise 64bits interger as underlying type (seams to be a known feature of win32 compiler)    -->

<!--- #     <enum name='liteClusterMask' desc='the given field mask'> -->
<!--- #       <enumval name = 'channelIDMask' value = '0xfffffffLL' desc='the channelID field mask'/> -->
<!--- #       <enumval name = 'clustToTMask' value = '0x70000000LL' desc='the clustToTMask field mask'/> -->
<!--- #       <enumval name = 'longPixMask' value = '0x80000000LL' desc='the longPixMask field mask'/> -->
<!--- #       <enumval name = 'interPixelFractionXMask' value = '0x700000000LL' desc='the interPixelFractionXMask field mask'/> -->
<!--- #       <enumval name = 'interPixelFractionYMask' value = '0x3800000000LL' desc='the interPixelFractionYMask field mask'/> -->
<!--- #     </enum>       -->  


<!--- Second attempt was to declare the mask fields as single attributes of type ulonglong. It solve the win32 problems    -->
<!--- BUT the size of the class goes from 8 to 48 (8 for each ulonglong) causing runtime error in the constructor of FastClusterContainer -->
<!--- since sizeof(ulonglong)!=sizeof(VPLiteCluster) -->

<!--- #    <attribute type='ulonglong' name='channelIDMask' setMeth="FALSE" getMeth="FALSE" desc='the channelID field mask' init='0xfffffffLL'/>-->
<!--- #    <attribute type='ulonglong' name='clustToTMask' setMeth="FALSE" getMeth="FALSE" desc='the clustToTMask field mask' init='0x70000000LL'/>-->
<!--- #    <attribute type='ulonglong' name='longPixMask' setMeth="FALSE" getMeth="FALSE" desc='the longPixMask field mask' init='0x80000000LL'/>-->
<!--- #    <attribute type='ulonglong' name='interPixelFractionXMask' setMeth="FALSE" getMeth="FALSE" desc='the interPixelFractionXMask field mask' init='0x700000000LL'/> -->
<!--- #    <attribute type='ulonglong' name='interPixelFractionYMask' setMeth="FALSE" getMeth="FALSE" desc='the interPixelFractionYMask field mask' init='0x3800000000LL'/> -->

<!--- Final choice was to hard code the mask. Since they are private it does not hurt outside world. Devellopers needs to be carefull -->
<!--- if changing the bitfield structure: the filed Mask will not automatically be updated. -->

  </class>
</package>
</gdd>

