<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE gdd SYSTEM 'gdd.dtd'>
<gdd>
  <package name='TrackEvent'>

<!-- ==================== Track class definition ==================== -->

    <class
      name        = 'Track'
      author      = 'Jose Hernando, Eduardo Rodrigues'
      desc        = 'Track is the base class for offline and online tracks.'
      id          = '10010'
      location    = 'Rec/Track/Best'
      keyedContTypeDef = "TRUE"
      stdVectorTypeDef = "TRUE">

      <location name="Ideal"   place="MC/Track/Ideal"/>
      <location name="Seed"    place="Rec/Track/Seed"/>
      <location name="RZVelo"  place="Rec/Track/RZVelo"/>
      <location name="Velo"    place="Rec/Track/Velo"/>
      <location name="Forward" place="Rec/Track/Forward"/>
      <location name="VeloTT"  place="Rec/Track/VeloTT"/>
      <location name="Match"   place="Rec/Track/Match"/>
      <location name="KsTrack" place="Rec/Track/KsTrack"/>
      <location name="Tsa"     place="Rec/Track/Tsa"/>

      <location name="HltSeed"    place="Hlt/Track/Seed"/>
      <location name="HltRZVelo"  place="Hlt/Track/RZVelo"/>
      <location name="HltVelo"    place="Hlt/Track/Velo"/>
      <location name="HltForward" place="Hlt/Track/Forward"/>
      <location name="HltVeloTT"  place="Hlt/Track/VeloTT"/>
      <location name="HltMatch"   place="Hlt/Track/Match"/>
      <location name="HltKsTrack" place="Hlt/Track/KsTrack"/>
      <location name="HltTsa"     place="Hlt/Track/Tsa"/>


      <base name='KeyedObject&lt;int&gt;' />
      &KeyedObject;

      <import name ="GaudiKernel/MsgStream"/>
      <import name='GaudiKernel/GaudiException' />
      <import name='Event/State' />
      <import name='Event/Measurement' />
      <import name='Event/Node' />
      <import name='Kernel/LHCbID' />
      <import name='Kernel/Plane3DTypes' />
      <import name='Kernel/GenericMatrixTypes' />

<!--
  /** Track history enumerations:
   *  each entry corresponds to the name of the pattern recognition
   *  algorithm that produced the Track
   *
   *   HistoryUnknown   : unkown history (i.e. history not set)
   *   TrackIdealPR     : track produced with the ideal pattern recognition
   *   TrackSeeding     : track produced with the seeding pattern recognition 
   *   PatVelo          : track produced with the VELO pattern recognition 
   *   PatVeloTT        : track produced with the online Velo-TT pattern recognition
   *   TrackVeloTT      : track produced with the offline Velo-TT pattern recognition
   *   PatForward
   *   TrgForward
   *   TrackMatching
   *   PatKShort
   *   TrackKShort
   *   TsaTrack
   *   CnvSeed         : seed tracks converted from old Track Event Model tracks
   *   CnvVelo         : velo tracks converted from old Track Event Model tracks
   *   CnvVeloBack     : velo Backwards tracks converted from old Track Event Model tracks
   *   CnvVeloTT       : veloTT tracks converted from old Track Event Model tracks
   *   CnvForward      : forward tracks converted from old Track Event Model tracks
   *   CnvMatch        : match tracks converted from old Track Event Model tracks
   *   CnvKsTrack      :
   *
   */
-->
      <enum
        name   = 'History'
        desc   = 'Track history enumerations'
        value  = 'HistoryUnknown=0,
                  TrackIdealPR,
                  TrackSeeding,
                  PatVelo,
                  PatVeloTT,
                  TrackVeloTT,
                  PatForward,
                  TrgForward,
                  TrackMatching,
                  PatKShort,
                  TrackKShort,
                  TsaTrack,
                  CnvSeed=24,
                  CnvVelo,
                  CnvVeloBack,
                  CnvVeloTT,
                  CnvForward,
                  CnvMatch,
                  CnvKsTrack'
        access = 'PUBLIC' />

<!--
  /** Track fit history enumerations
   *
   *   FitUnknown  : track not fitted yet (fit history not set)
   *   StdKalman   : track fitted with the standard Kalman fitter
   *   BiKalman    : track fitted with the bi-directional Kalman fitter
   *
   */
-->
      <enum
        name   = 'FitHistory'
        desc   = 'Track fit history enumerations'
        value  = 'FitUnknown=0,
                  StdKalman,
                  BiKalman'
        access = 'PUBLIC' />

<!--
  /** Track type enumerations
   *
   *   TypeUnknown   : track of undefined type (not to be used!)
   *   Velo          : VELO track
   *   VeloR         : 2D VELO track
   *   Long          : forward track
   *   Upstream      : upstream track
   *   Downstream    : downstream track
   *   Ttrack        : seed track
   *
   */
-->
      <enum
        name   = 'Types'
        desc   = 'Track type enumerations'
        value  = 'TypeUnknown=0,
                  Velo,
                  VeloR,
                  Long,
                  Upstream,
                  Downstream,
                  Ttrack'
        access = 'PUBLIC' />

<!--
  /** Track pattern recognition status flag enumerations:
   *  The flag specifies in which state of the pattern recognition phase the
   *  track is. The status flag is set by the relevant algorithms
   *
   *   PatRecStatusUnknown   : track in an undefined PR status
   *   PatRecIDs             : pattern recognition track with LHCbIDs
   *   PatRecMeas            : pattern recognition track with Measurements added
   *   Fitted                : fitted track
   *   FitFailed             : track for which the track fit failed
   *
   */
-->
      <enum
        name   = 'PatRecStatus'
        desc   = 'Track pattern recognition status flag enumerations'
        value  = 'PatRecStatusUnknown=0,
                  PatRecIDs,
                  PatRecMeas'
        access = 'PUBLIC' />

<!--
  /** Track fit status flag enumerations:
   *  The flag specifies in which state of the fitting phase the
   *  track is. The status flag is set by the relevant algorithms
   *
   *   FitStatusUnknown   : track in an undefined fitting status
   *   Fitted             : fitted track
   *   FitFailed          : track for which the track fit failed
   *
   */
-->
      <enum
        name   = 'FitStatus'
        desc   = 'Track fitting status flag enumerations'
        value  = 'FitStatusUnknown=0,
                  Fitted,
                  FitFailed'
        access = 'PUBLIC' />


<!--
  /** Track general flags enumerations
   *
   *   Backward      : VELO track in the backward direction
   *   Invalid       : invalid track for physics
   *   Clone         : clone track (of a corresponding unique track)
   *   IPSelected    :
   *   PIDSelected   : 
   *
   */
-->
      <enum
        name   = 'Flags'
        desc   = 'Track general flags enumerations'
        value  = 'Backward=1,
                  Invalid=2,
                  Clone=4,
                  Used=8,
                  IPSelected=16,
                  PIDSelected=32'
        access = 'PUBLIC' />

      <constructor 
	desc     = "Constructor with assigned key" 
	argList  = "int key "
	initList = "KeyedObject&lt;int&gt;( key ), m_chi2PerDoF(0.0), m_nDoF(0), m_flags(0), m_lhcbIDs(), m_states(), m_measurements(), m_nodes(), m_ancestors()">
      </constructor>

      <destructor
        desc = 'Track destructor'>
        <code>
  reset();
        </code>
      </destructor>

      <attribute
        type   = 'double'
        name   = 'chi2PerDoF'
        desc   = 'chi^2 per degree of freedom of the Track'
        access = 'PROTECTED' />

      <attribute
        type   = 'int'
        name   = 'nDoF'
        desc   = 'number of degrees of freedom of the Track'
        access = 'PROTECTED' />

     <attribute
       type    = 'bitfield'
       name    = 'flags'
       desc    = 'the variety of Track flags'
       init    = '0'
       access  = 'PROTECTED'>
       <bitfield
         type      = 'LHCb::Track::Types'
         name      = 'type'
         length    = '4'
         desc      = 'Track type'
         setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         type      = 'LHCb::Track::History'
         name      = 'history'
         length    = '7'
         desc      = 'specifies the pattern recognition algorithm that created the Track'
         setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         type      = 'LHCb::Track::FitHistory'
         name      = 'fitHistory'
         length    = '3'
         desc      = 'specifies the fitting algorithm the fitted the Track)'
         setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         type      = 'LHCb::Track::PatRecStatus'
         name      = 'patRecStatus'
         length    = '2'
         desc      = 'pattern recognition status of the Track'
	 setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         type      = 'LHCb::Track::FitStatus'
         name      = 'fitStatus'
         length    = '2'
         desc      = 'fitting status of the Track'
	 setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         type      = 'LHCb::Track::Flags'
         name      = 'flag'
         length    = '10'
         desc      = 'Track flags'
         setMeth   = 'FALSE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         name      = 'specific'
         length    = '4'
         desc      = 'Track specific bits'
         setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
      </attribute>

      <attribute
        type      = 'std::vector&lt;LHCb::LHCbID&gt;'
        name      = 'lhcbIDs'
        desc      = 'container of LHCbIDs'
        access    = 'PROTECTED' />

      <attribute
        type      = 'std::vector&lt;LHCb::State*&gt;'
        name      = 'states'
        desc      = 'container with pointers to all the states'
        access    = 'PROTECTED'
        setMeth   = 'FALSE' />

      <attribute
        type      = 'std::vector&lt;LHCb::Measurement*&gt;'
        name      = 'measurements'
        desc      = 'container of Measurements'
        access    = 'PROTECTED'
        setMeth   = 'FALSE'
        transient = 'TRUE' />

      <attribute
        type      = 'std::vector&lt;LHCb::Node*&gt;'
        name      = 'nodes'
        desc      = 'container of Nodes'
        access    = 'PROTECTED'
        setMeth   = 'FALSE'
        transient = 'TRUE'
	nonconstaccessor = 'TRUE' />

      <relation
        type         = "LHCb::Track"
        name         = "ancestors"
        access       = 'PROTECTED'
        setMeth      = 'FALSE'
        desc         = "ancestor Tracks that created this one" 
        multiplicity = "N" 
        serialize    = 'FALSE' />

      <method
        type    = 'void'
        name    = 'positionAndMomentum'
        desc    = 'Retrieve the position and momentum vectors and the corresponding 6D covariance matrix (pos:1->3,mom:4-6) at the first state'
        const   = 'TRUE'>
        <arg type = 'Gaudi::XYZPoint' name='pos' />
        <arg type = 'Gaudi::XYZVector' name='mom' />
        <arg type = 'Gaudi::SymMatrix6x6' name='cov6D' />
      </method>

      <method
        type    = 'void'
        name    = 'positionAndMomentum'
        desc    = 'Retrieve the position and momentum vectors at the first state'
        const   = 'TRUE'>
        <arg type = 'Gaudi::XYZPoint' name='pos' />
        <arg type = 'Gaudi::XYZVector' name='mom' />
      </method>

      <method
        type    = 'Gaudi::XYZPoint'
        name    = 'position'
        desc    = 'Retrieve the 3D-position vector at the first state'
        const   = 'TRUE'>
        <code>
  return firstState().position();
        </code>
      </method>

      <method
        type    = 'void'
        name    = 'position'
        desc    = 'Retrieve the 3D-position (+ errors) at the first state'
        const   = 'TRUE'>
        <arg type = 'Gaudi::XYZPoint' name='pos' />
        <arg type = 'Gaudi::SymMatrix3x3' name='errPos' />
      </method>

    <method
        type    = 'Gaudi::XYZVector'
        name    = 'slopes'
        desc    = 'Retrieve the slopes (Tx=dx/dz,Ty=dy/dz,1.) and errors at the first state'
        const   = 'TRUE'>
        <code>
   return firstState().slopes();
        </code>
      </method>

      <method
        type    = 'void'
        name    = 'slopes'
        desc    = 'Retrieve the slopes (dx/dz,dy/dz,1) at the first state'
        const   = 'TRUE'>
        <arg type = 'Gaudi::XYZVector' name='slopes' />
        <arg type = 'Gaudi::SymMatrix3x3' name='errSlopes' />
      </method>

      <method
        type    = 'Gaudi::XYZVector'
        name    = 'momentum'
        desc    = 'Retrieve the momentum vector at the first state'
        const   = 'TRUE'>
        <code>
  return firstState().momentum();
        </code>
      </method>

      <method
        type    = 'double'
        name    = 'p'
        desc    = 'Retrieve the momentum at the first state'
        const   = 'TRUE' />

      <method
        type    = 'double'
        name    = 'pt'
        desc    = 'Retrieve the transverse momentum at the first state'
        const   = 'TRUE' />

      <method
        type    = 'void'
        name    = 'momentum'
        desc    = 'Retrieve the momentum vector (+ errors) at the first state'
        const   = 'TRUE'>
        <arg type = 'Gaudi::XYZVector' name='mom' />
        <arg type = 'Gaudi::SymMatrix3x3' name='errMom' />
      </method>

      <method
        type    = 'void'
        name    = 'posMomCovariance'
        desc    = 'Retrieve the 6D covariance matrix (x,y,z,px,py,pz) at the first state'
        const   = 'TRUE'>
        <arg type='Gaudi::SymMatrix6x6' name='cov6D' />
      </method>

      <method
        type    = 'LHCb::State &amp;'
        name    = 'firstState'
        desc    = 'Retrieve the first state on the Track'
        const   = 'TRUE'>
        <code>
  // check at least the &quot;first state&quot; exists
  if ( m_states.empty() )
    throw GaudiException( &quot;first (first) state not defined!&quot;,
                          &quot;Track.h&quot;,
                          StatusCode::FAILURE );
  return *m_states[0];
        </code>
      </method>

      <method
        type    = 'int'
        name    = 'charge'
        desc    = 'Retrieve the charge assigned to the Track'
        const   = 'TRUE'>
        <code>
  double qP = firstState().qOverP();
  return ( qP != 0. ? int(fabs(qP)/qP) : 0 );
        </code>
      </method>

      <method
        type    = 'double'
        name    = 'chi2'
        desc    = 'Retrieve the Chi^2 of the Track (fit)'
        const   = 'TRUE'>
        <code>
  return ( m_chi2PerDoF * double(m_nDoF) );
        </code>
      </method>

      <method
        type    = 'unsigned int'
        name    = 'nStates'
        desc    = 'Retrieve the number of states on the Track'
        const   = 'TRUE'>
        <code>
  return m_states.size();
        </code>
      </method>
      
      <method
        name    = 'addToStates'
        desc    = 'Add a State to the list of States associated to the Track'>
        <arg type = 'const LHCb::State' name=' state' />
      </method>

      <method
        name    = 'removeFromStates'
        desc    = 'Remove a State from the list of states associated to the Track'
        argList = 'LHCb::State* value'>
      </method>

      <method
        type    = 'void'
        name    = 'clearStates'
        desc    = 'Clear the State vector'>
      </method>

      <method
        type    = 'LHCb::State &amp;'
        name    = 'closestState'
        argList = 'double z'
        desc    = 'Retrieve the reference to the state closest to the given z-position' />

      <method
        type    = 'const LHCb::State &amp;'
        name    = 'closestState'
        argList = 'double z'
        desc    = 'Retrieve the reference to the state closest to the given z-position'
        const   = 'TRUE' />

      <method
        type    = 'LHCb::State &amp;'
        name    = 'closestState'
        argList = 'const Gaudi::Plane3D plane'
        desc    = 'Retrieve the reference to the state closest to the given plane' />

      <method
        type    = 'const LHCb::State &amp;'
        name    = 'closestState'
        argList = 'const Gaudi::Plane3D plane'
        desc    = 'Retrieve the reference to the state closest to the given plane'
        const   = 'TRUE' />

      <method
        type    = 'bool'
        name    = 'hasStateAt'
        argList = 'const LHCb::State::Location&amp; location'
        desc    = 'Check the existence of a state at a certain predefined location (see the Location enum in State.h)'
        const   = 'TRUE' />

      <method
        type    = 'LHCb::State &amp;'
        name    = 'stateAt'
        argList = 'const LHCb::State::Location&amp; location'
        desc    = 'Retrieve the state at a certain predefined location (see the Location enum in State.h)' />

      <method
        type    = 'const LHCb::State &amp;'
        name    = 'stateAt'
        argList = 'const LHCb::State::Location&amp; location'
        desc    = 'Retrieve the const state at a certain predefined location (see the Location enum in State.h)'
        const   = 'TRUE' />

      <method
        type    = 'unsigned int'
        name    = 'nLHCbIDs'
        desc    = 'Retrieve the number of LHCbIDs on the Track'
        const   = 'TRUE'>
        <code>
  return m_lhcbIDs.size();
        </code>
      </method>

      <method
        type    = 'unsigned int'
        name    = 'nMeasurements'
        desc    = 'Retrieve the number of Measurements on the Track'
        const   = 'TRUE'>
        <code>
  return m_measurements.size();
        </code>
      </method>

      <method
        name    = 'addToMeasurements'
        desc    = 'Add a Measurement to the list associated to the Track'>
        <arg type = 'const LHCb::Measurement' name='meas' />
      </method>

     <method
        name    = 'removeFromMeasurements'
        desc    = 'Remove a Measurement from the list of Measurements associated to the Track'
        argList = 'LHCb::Measurement* value'>
      </method>

      <method
        name    = 'addToNodes'
        desc    = 'Add a Node to the list of Nodes (note: Track will take the ownership of this pointer!!)'>
        <arg type = 'Node*' name='node' />
        <code>
  m_nodes.push_back( node );
        </code>
      </method>

     <method
        name    = 'removeFromNodes'
        desc    = 'Remove a Node from the list of Nodes associated to the Track'
        argList = 'Node* value'>
      </method>

     <method
        name    = 'addToLhcbIDs'
        desc    = 'Add an LHCbID to the list of LHCbIDs associated to the Track'
        argList = 'LHCb::LHCbID value'>
        <code>
  if ( !isOnTrack( value ) ) m_lhcbIDs.push_back( value );
        </code>
      </method>

     <method
        name    = 'removeFromLhcbIDs'
        desc    = 'Remove an LHCbID from the list of LHCbIDs associated to the Track'
        argList = 'LHCbID value' />

      <method
        name    = 'addToAncestors'
        desc    = 'Add a Track to the list of ancestors of this Track'>
        <arg type = 'const LHCb::Track ' name='ancestor' />
        <code>
  m_ancestors.push_back( (LHCb::Track*) &amp;ancestor );
        </code>
      </method>

      <method
        type    = 'void'
        name    = 'reset'
        desc    = 'Clear the Track before re-use'
	virtual = 'TRUE'>
      </method>

      <method
        type    = 'LHCb::Track*'
        name    = 'cloneWithKey'
        desc    = 'Clone the Track keeping the key (you take ownership of the pointer)'
	const   = 'TRUE'
        virtual = 'TRUE' />

      <method
        type    = 'LHCb::Track*'
        name    = 'clone'
        desc    = 'Clone the Track (you take ownership of the pointer)'
	const   = 'TRUE'
        virtual = 'TRUE' />

      <method
        type    = 'void'
        name    = 'copy'
        argList = 'const LHCb::Track&amp; track'
        desc    = 'Copy the info from the argument track into this track'
	virtual = 'TRUE' />

      <method
        type    = 'bool'
        name    = 'checkType'
        argList = 'const LHCb::Track::Types&amp; value'
        desc    = 'Check the type of the Track (see the Types enum)'
        const   = 'TRUE'>
        <code>
  return type() == value;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'checkHistory'
        argList = 'const LHCb::Track::History&amp; value'
        desc    = 'Check the history of the Track (see the History enum)'
        const   = 'TRUE'>
        <code>
  return history() == value;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'checkFitHistory'
        argList = 'const LHCb::Track::FitHistory&amp; value'
        desc    = 'Check the fit history of the Track (see the FitHistory enum)'
        const   = 'TRUE'>
        <code>
  return fitHistory() == value;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'checkPatRecStatus'
        argList = 'const LHCb::Track::PatRecStatus&amp; value'
        desc    = 'Check the pattern recognition status of the Track (see the PatRecStatus enum)'
        const   = 'TRUE'>
        <code>
  return patRecStatus() == value;
        </code>
      </method>

      <method
        name    = 'setFlag'
        argList = 'unsigned int flag, bool ok'
        desc    = 'Update the flag (see the Flags enum)'>
        <code>
  unsigned int val = (((unsigned int) flag) &lt;&lt; flagBits) &amp; flagMask;
  if (ok) m_flags |= val;
  else m_flags &amp;= ~val;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'checkFlag'
        argList = 'const LHCb::Track::Flags&amp; flag'
        desc    = 'Check the status of the flag (see the Flags enum)'
        const   = 'TRUE'>
        <code>
  unsigned int val = ((unsigned int) flag &lt;&lt; flagBits);  
  bool ok = (0 != ( m_flags &amp; flagMask &amp; val ));
  return ok;
        </code>
      </method>

      <method
        type    = 'unsigned int'
        name    = 'nMeasurementsRemoved'
        desc    = 'Retrieve the number of Measurements removed by the Track fit (the number of LHCbIDs remains unchanged)'
        const   = 'TRUE'>
        <code>
  return ( ( nMeasurements() > 0 ) ? ( nLHCbIDs() - nMeasurements() ) : 0 );
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'isOnTrack'
        argList = 'const LHCb::LHCbID value'
        desc    = 'Check whether the given LHCbID is on the Track'
        const   = 'TRUE'>
      </method>

      <method
        type    = 'bool'
        name    = 'isOnTrack'
        argList = 'const LHCb::Measurement value'
        desc    = 'Check whether the given Measurement is on the Track'
        const   = 'TRUE'>
      </method>


      <method
        type    = 'bool'
        name    = 'isMeasurementOnTrack'
        argList = 'const LHCb::LHCbID value'
        desc    = 'Check whether the Measurement on the Track corresponding to the input LHCbID is present'
        const   = 'TRUE' />

      <method
        type    = 'const LHCb::Measurement&amp;'
        name    = 'measurement'
        argList = 'const LHCb::LHCbID value'
        desc    = 'Return the Measurement on the Track corresponding to the input LHCbID. Call first the "isMeasurementOnTrack" method before calling this one, as it throws an exception if the LHCbID is not present! (ONLY for tracking code, not for general use.)'
        const   = 'TRUE' />

      <method
        type    = 'LHCb::Measurement&amp;'
        name    = 'measurement'
        argList = 'const LHCb::LHCbID value'
	desc    = 'Return the Measurement on the Track corresponding to the input LHCbID. Call first the "isMeasurementOnTrack" method before calling this one, as it throws an exception if the LHCbID is not present! (ONLY for tracking code, not for general use.)' />
      
      <method
	name      = "fillStream"
	desc      = "printOut method to Gaudi message stream"
	type      = "MsgStream&amp;"
	virtual   = "TRUE"
	const     = "TRUE" >
	<arg name = "os" type = "MsgStream" inout = "BOTH"/>
	<code>
  os &lt;&lt; "{ "
     &lt;&lt; "chi2PerDoF : " &lt;&lt; (float)m_chi2PerDoF &lt;&lt; std::endl
     &lt;&lt; "nDoF : " &lt;&lt; m_nDoF &lt;&lt; std::endl
     &lt;&lt; "flags : " &lt;&lt; m_flags &lt;&lt; std::endl
     &lt;&lt; "lhcbIDs : " &lt;&lt; m_lhcbIDs &lt;&lt; std::endl
     &lt;&lt; "states :	" &lt;&lt; m_states &lt;&lt; std::endl
     &lt;&lt; "measurements : " &lt;&lt; m_measurements &lt;&lt; std::endl
     &lt;&lt; "nodes :	" &lt;&lt; m_nodes &lt;&lt; std::endl
     &lt;&lt; " }";
  return os;
	</code>
      </method>

    </class>

  </package>
</gdd>
