<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE gdd SYSTEM 'gdd.dtd'>
<gdd>
  <package name='TrackEvent'>

<!-- ==================== Track class definition ==================== -->

    <class
      name        = 'Track'
      author      = 'Jose Hernando, Eduardo Rodrigues'
      desc        = 'Track is the base class for offline and online tracks.'
      id          = '10010'
      location    = 'Rec/Track/Best'
      keyedContTypeDef = "TRUE"
      stdVectorTypeDef = "TRUE">

      <location name="Ideal"   place="MC/Track/Ideal"/>
      <location name="Seed"    place="Rec/Track/Seed"/>
      <location name="RZVelo"  place="Rec/Track/RZVelo"/>
      <location name="Velo"    place="Rec/Track/Velo"/>
      <location name="Forward" place="Rec/Track/Forward"/>
      <location name="VeloTT"  place="Rec/Track/VeloTT"/>
      <location name="Match"   place="Rec/Track/Match"/>
      <location name="KsTrack" place="Rec/Track/KsTrack"/>
      <location name="Tsa"     place="Rec/Track/Tsa"/>
      <location name="Muon"    place="Rec/Track/Muon"/>

      <location name="HltSeed"    place="Hlt/Track/Seed"/>
      <location name="HltRZVelo"  place="Hlt/Track/RZVelo"/>
      <location name="HltVelo"    place="Hlt/Track/Velo"/>
      <location name="HltForward" place="Hlt/Track/Forward"/>
      <location name="HltVeloTT"  place="Hlt/Track/VeloTT"/>
      <location name="HltMatch"   place="Hlt/Track/Match"/>
      <location name="HltKsTrack" place="Hlt/Track/KsTrack"/>
      <location name="HltTsa"     place="Hlt/Track/Tsa"/>
      <location name="HltMuon"    place="Hlt/Track/Muon"/>


      <base name='KeyedObject&lt;int&gt;' />
      &KeyedObject;

      <import name="GaudiKernel/MsgStream"/>
      <import name='GaudiKernel/GaudiException' />
      <import name='Event/State' />
      <import name='Event/Measurement' />
      <import name='Event/Node' />
      <import name='Kernel/LHCbID' />
      <import name='GaudiKernel/Plane3DTypes' />
      <import name='GaudiKernel/GenericMatrixTypes' />
      <import name="GaudiKernel/VectorMap"/>

      <enum
        name   = 'History'
        desc   = 'Track history enumerations: each entry corresponds to the name of the pattern recognition algorithm that produced the Track'
        access = 'PUBLIC' >
        <enumval name = "HistoryUnknown" value="0" desc="unknown history (i.e. history not set)"/>
        <enumval name = "TrackIdealPR"   value="1" desc="track produced with the ideal pattern recognition"/>
        <enumval name = "TrackSeeding"   value="2" desc="track produced with the seeding pattern recognition"/>
        <enumval name = "PatVelo"        value="3" desc="track produced with the 2D then 3D VELO pattern recognition"/>
        <enumval name = "PatVeloTT"      value="4" desc="track produced with the online Velo-TT pattern recognition"/>
        <enumval name = "TrackVeloTT"    value="5" desc="track produced with the offline Velo-TT pattern recognition"/>
        <enumval name = "PatForward"     value="6" desc="track produced with the forward pattern recognition"/>
        <enumval name = "TrackMatching"  value="7" desc=""/>
        <enumval name = "PatKShort"      value="8" desc=""/>
        <enumval name = "TsaTrack"       value="9" desc=""/>
        <enumval name = "MuonID"         value="10" desc="track produced with the Muon pattern recognition"/>
        <enumval name = "PatVeloR"       value="11" desc="produced with the 2D VELO pattern recognition"/>
        <enumval name = "PatVeloGeneric" value="12" desc="produced with the VELO Generic pattern recognition"/>
        <enumval name = "PatVeloGeneral" value="13" desc="produced with the VELO General pattern recognition"/>
        <enumval name = "PatVeloOpen"    value="14" desc="produced with the VELO open pattern recognition"/>
      </enum>

      <enum
        name   = 'FitHistory'
        desc   = 'Track fit history enumerations'
        access = 'PUBLIC' >
        <enumval name = "FitUnknown" value="0" desc="track not fitted yet (fit history not set)"/>
        <enumval name = "StdKalman"            desc="track fitted with the standard Kalman fitter"/>
        <enumval name = "BiKalman"             desc="track fitted with the bi-directional Kalman fitter"/>
      </enum>

      <enum
        name   = 'Types'
        desc   = 'Track type enumerations'
        access = 'PUBLIC' >
        <enumval name = "TypeUnknown" value="0" desc="track of undefined type"/>
        <enumval name = "Velo"        desc="VELO track"/>
        <enumval name = "VeloR"       desc="2D VELO track"/>
        <enumval name = "Long"        desc="forward track"/>
        <enumval name = "Upstream"    desc="upstream track"/>
        <enumval name = "Downstream"  desc="downstream track"/>
        <enumval name = "Ttrack"      desc="seed track"/>
        <enumval name = "Muon"        desc="muon track"/>
      </enum>

      <enum
        name   = 'PatRecStatus'
        desc   = 'Track pattern recognition status flag enumerations: The flag specifies in which state of the pattern recognition phase the track is. The status flag is set by the relevant algorithms'
        access = 'PUBLIC' >
        <enumval name = "PatRecStatusUnknown" value="0" desc="track in an undefined PR status"/>
        <enumval name = "PatRecIDs"                     desc="pattern recognition track with LHCbIDs"/>
        <enumval name = "PatRecMeas"                    desc="pattern recognition track with Measurements added"/>
      </enum>

      <enum
        name   = 'FitStatus'
        desc   = 'Track fitting status flag enumerations: The flag specifies in which state of the fitting phase the track is. The status flag is set by the relevant algorithms'
        access = 'PUBLIC' >
        <enumval name = "FitStatusUnknown" value="0" desc="track in an undefined fitting status"/>
        <enumval name = "Fitted"                     desc="fitted track"/>
        <enumval name = "FitFailed"                  desc="track for which the track fit failed"/>
      </enum>

      <enum
        name   = 'Flags'
        desc   = 'Track general flags enumerations'
        access = 'PUBLIC' >
        <enumval name = "Backward"    value=  "1" desc="VELO track in the backward direction"/>
        <enumval name = "Invalid"     value=  "2" desc="invalid track for physics"/>
        <enumval name = "Clone"       value=  "4" desc="clone track (of a corresponding unique track)"/>
        <enumval name = "Used"        value=  "8" desc=""/>
        <enumval name = "IPSelected"  value= "16" desc=""/>
        <enumval name = "PIDSelected" value= "32" desc=""/>
        <enumval name = "Selected"    value= "64" desc=""/>
        <enumval name = "L0Candidate" value="128" desc=""/>
      </enum>
  
      <enum
        desc   = "Additional information assigned to this Track by pattern recognition"
        name   = "AdditionalInfo"
        access = "PUBLIC" >
        <enumval name = "Likelihood" value = "1" desc="The Likelihood the track is real"/>
        <enumval name = "PatQuality" value = "2" desc="Quality variable from PatForward Tracking"/>
	<enumval name = "Cand2ndQPat"      value = "3"  desc=" Quality of the second candidate"/>
        <enumval name = "NCandCommonHits"  value = "4"  desc=" NCand with common hits"/>
        <enumval name = "Cand2ndChi2Mat"   value = "5"  desc=" Chi2 of the second candidate"/>
        <enumval name = "nExpectedVelo" value = "10" desc="number of expected Velo hits"/>
        <enumval name = "nExpectedTT" value = "11" desc="number of expected TT hits"/>
        <enumval name = "nExpectedIT" value = "12" desc="number of expected IT hits"/>
        <enumval name = "nExpectedOT" value = "13" desc="number of expected OT hits"/>
        <enumval name = "MatchChi2"  value = "16" desc="Chi2 from the velo-seed matching (TrackMatching)"/>
        <enumval name = "FitVeloChi2"  value = "17" desc="Chi2 of the velo segment (from TrackFit)"/>
        <enumval name = "FitVeloNDoF"  value = "18" desc="NDoF of the velo segment chisq"/>
        <enumval name = "FitTChi2"     value = "19" desc="Chi2 of the T station segment (from TrackFit)"/>
        <enumval name = "FitTNDoF"     value = "20" desc="NDoF of the T station segment chisq"/>
        <enumval name = "FitMatchChi2" value = "21" desc="Chi2 of the breakpoint between T and TT (from TrackFit)"/>
	<enumval name = "TsaLikelihood" value = "32" desc ="Likelihood from tsa seeding"/> 
        <enumval name = "CloneDist"  value = "101" desc="Track is flagged as being a (rejected) clone of another track. Value is the KL clone distance"/>
        <enumval name = "GhostProbability" value = "102" desc=" gives the NN ghost probability"/>
       </enum>

   <typedef
        type   = "GaudiUtils::VectorMap&lt;int,double&gt;"
        def    = "ExtraInfo"
        desc   = "Vector of additional information"
        access = "PUBLIC"
   />

   <constructor 
	desc     = "Constructor with assigned key" 
	argList  = "int key "
	initList = "KeyedObject&lt;int&gt;( key ), m_chi2PerDoF(0.0), m_nDoF(0), m_flags(0), m_lhcbIDs(), m_states(), m_measurements(), m_nodes(), m_ancestors()">
      </constructor>

      <destructor
        desc = 'Track destructor'>
        <code>
  reset();
        </code>
      </destructor>

      <attribute
        type   = 'double'
        name   = 'chi2PerDoF'
        desc   = 'Chi^2 per degree of freedom of the track'
        access = 'PROTECTED' />

      <attribute
        type   = 'int'
        name   = 'nDoF'
        desc   = 'Number of degrees of freedom of the track'
        access = 'PROTECTED' />

     <attribute
       type    = 'bitfield'
       name    = 'flags'
       desc    = 'The variety of track flags'
       init    = '0'
       access  = 'PROTECTED'>
       <bitfield
         type      = 'LHCb::Track::Types'
         name      = 'type'
         length    = '4'
         desc      = 'Track type'
         setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         type      = 'LHCb::Track::History'
         name      = 'history'
         length    = '7'
         desc      = 'Specifies the pattern recognition algorithm that created the track'
         setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         type      = 'LHCb::Track::FitHistory'
         name      = 'fitHistory'
         length    = '3'
         desc      = 'Specifies the fitting algorithm the fitted the track)'
         setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         type      = 'LHCb::Track::PatRecStatus'
         name      = 'patRecStatus'
         length    = '2'
         desc      = 'Pattern recognition status of the track'
	 setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         type      = 'LHCb::Track::FitStatus'
         name      = 'fitStatus'
         length    = '2'
         desc      = 'Fitting status of the track'
	 setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         type      = 'LHCb::Track::Flags'
         name      = 'flag'
         length    = '10'
         desc      = 'Track flags'
         setMeth   = 'FALSE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         name      = 'specific'
         length    = '4'
         desc      = 'Track specific bits'
         setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
      </attribute>

      <attribute
        type      = 'std::vector&lt;LHCb::LHCbID&gt;'
        name      = 'lhcbIDs'
        desc      = 'Container of LHCbIDs'
        access    = 'PROTECTED' />

      <attribute
        type      = 'std::vector&lt;LHCb::State*&gt;'
        name      = 'states'
        desc      = 'Container with pointers to all the states'
        access    = 'PROTECTED'
        setMeth   = 'FALSE' />

      <attribute
        type      = 'std::vector&lt;LHCb::Measurement*&gt;'
        name      = 'measurements'
        desc      = 'Container of Measurements'
        access    = 'PROTECTED'
        setMeth   = 'FALSE'
        transient = 'TRUE' />

      <attribute
        type      = 'std::vector&lt;LHCb::Node*&gt;'
        name      = 'nodes'
        desc      = 'Container of Nodes'
        access    = 'PROTECTED'
        setMeth   = 'FALSE'
        transient = 'TRUE'
	nonconstaccessor = 'TRUE' />

      <attribute
        name    = "extraInfo"
        desc    = "Additional pattern recognition information. Do not access directly, use *Info() methods instead."
        type    = "ExtraInfo"
        getMeth = "TRUE"
        access  = "PROTECTED" />

      <relation
        type         = 'LHCb::Track'
        name         = 'ancestors'
        desc         = 'Ancestor tracks that created this one'
        access       = 'PROTECTED'
        setMeth      = 'FALSE'
        multiplicity = 'N'
	nonconstaccessor = 'TRUE' />

      <method
        type    = 'void'
        name    = 'positionAndMomentum'
        desc    = 'Retrieve the position and momentum vectors and the corresponding 6D covariance matrix (pos:0->2,mom:3-5) at the first state'
        const   = 'TRUE'>
        <arg type = 'Gaudi::XYZPoint' name='pos' />
        <arg type = 'Gaudi::XYZVector' name='mom' />
        <arg type = 'Gaudi::SymMatrix6x6' name='cov6D' />
        <code>
 firstState().positionAndMomentum( pos, mom, cov6D );
        </code>
      </method>

      <method
        type    = 'void'
        name    = 'positionAndMomentum'
        desc    = 'Retrieve the position and momentum vectors at the first state'
        const   = 'TRUE'>
        <arg type = 'Gaudi::XYZPoint' name='pos' />
        <arg type = 'Gaudi::XYZVector' name='mom' />
       <code>
 firstState().positionAndMomentum( pos, mom );
       </code>
      </method>

      <method
        type    = 'Gaudi::XYZPoint'
        name    = 'position'
        desc    = 'Retrieve the 3D-position vector at the first state'
        const   = 'TRUE'>
        <code>
  return firstState().position();
        </code>
      </method>

      <method
        type    = 'void'
        name    = 'position'
        desc    = 'Retrieve the 3D-position (+ errors) at the first state'
        const   = 'TRUE'>
        <arg type = 'Gaudi::XYZPoint' name='pos' />
        <arg type = 'Gaudi::SymMatrix3x3' name='errPos' />
       <code>
  pos    = firstState().position();
  errPos = firstState().errPosition();
       </code>
      </method>

    <method
        type    = 'Gaudi::XYZVector'
        name    = 'slopes'
        desc    = 'Retrieve the slopes (Tx=dx/dz,Ty=dy/dz,1.) and errors at the first state'
        const   = 'TRUE'>
        <code>
   return firstState().slopes();
        </code>
      </method>

      <method
        type    = 'void'
        name    = 'slopes'
        desc    = 'Retrieve the slopes (Tx=dx/dz,Ty=dy/dz,1.) at the first state'
        const   = 'TRUE'>
        <arg type = 'Gaudi::XYZVector' name='slopes' />
        <arg type = 'Gaudi::SymMatrix3x3' name='errSlopes' />
        <code>
   slopes    = firstState().slopes();
   errSlopes = firstState().errSlopes();
        </code>
      </method>

      <method
        type    = 'Gaudi::XYZVector'
        name    = 'momentum'
        desc    = 'Retrieve the momentum vector at the first state'
        const   = 'TRUE'>
        <code>
  return this->firstState().momentum();
        </code>
      </method>

      <method
        type    = 'double'
        name    = 'p'
        desc    = 'Retrieve the momentum at the first state'
        const   = 'TRUE'>
        <code>
  return this->firstState().p();
        </code>
      </method>

      <method
        type    = 'double'
        name    = 'pt'
        desc    = 'Retrieve the transverse momentum at the first state'
        const   = 'TRUE'>
        <code>
  return this->firstState().pt();
        </code>
      </method>

      <method
        type    = 'double'
        name    = 'pseudoRapidity'
        desc    = 'Retrieve the pseudorapidity at the first state'
        const   = 'TRUE'>
        <code>
  return this->slopes().eta() ;
        </code>
      </method>

      <method
        type    = 'double'
        name    = 'phi'
        desc    = 'Retrieve the phi at the first state'
        const   = 'TRUE'>
        <code>
  return this->slopes().phi() ;
        </code>
      </method>

      <method
        type    = 'void'
        name    = 'momentum'
        desc    = 'Retrieve the momentum vector (and errors) at the first state'
        const   = 'TRUE'>
        <arg type = 'Gaudi::XYZVector' name='mom' />
        <arg type = 'Gaudi::SymMatrix3x3' name='errMom' />
        <code>
  mom    = firstState().momentum();
  errMom = firstState().errMomentum();
        </code>
      </method>

      <method
        type    = 'void'
        name    = 'posMomCovariance'
        desc    = 'Retrieve the 6D (x,y,z,px,py,pz) covariance matrix at the first state'
        const   = 'TRUE'>
        <arg type='Gaudi::SymMatrix6x6' name='cov6D' />
        <code>
 cov6D = firstState().posMomCovariance();
        </code>
      </method>

      <method
        type    = 'LHCb::State &amp;'
        name    = 'firstState'
        desc    = 'Retrieve the first state on the track'
        const   = 'TRUE'>
        <code>
  // check at least the &quot;first state&quot; exists
  if ( m_states.empty() )
    throw GaudiException( &quot;first state not defined!&quot;,
                          &quot;Track.h&quot;,
                          StatusCode::FAILURE );
  return *m_states[0];
        </code>
      </method>

      <method
        type    = 'int'
        name    = 'charge'
        desc    = 'Retrieve the charge assigned to the track'
        const   = 'TRUE'>
        <code>
  double qP = firstState().qOverP();
  return ( fabs(qP)  &gt; TrackParameters::lowTolerance  ? int(fabs(qP)/qP) : 0 );
        </code>
      </method>

      <method
        type    = 'double'
        name    = 'chi2'
        desc    = 'Retrieve the Chi^2 of the track (fit)'
        const   = 'TRUE'>
        <code>
  return ( m_chi2PerDoF * double(m_nDoF) );
        </code>
      </method>

      <method
        type    = 'void'
        name    = 'setChi2AndDoF'
        desc    = 'Set the Chi^2 and the DoF of the track (fit)'
        argList = 'double chi2, int ndof'
        const   = 'FALSE'>
        <code>
  m_chi2PerDoF = ( ndof != 0 ) ? chi2/((double) (ndof)) : 0.0;
  m_nDoF = ndof;
        </code>
      </method>

      <method
        type    = 'double'
        name    = 'probChi2'
        desc    = 'Probability of chi2^2 of the track'
        const   = 'TRUE'>
      </method>

      <method
        type    = 'unsigned int'
        name    = 'nStates'
        desc    = 'Retrieve the number of states on the track'
        const   = 'TRUE'>
        <code>
  return m_states.size();
        </code>
      </method>
      
      <method
        name    = 'addToStates'
        desc    = 'Add a State to the list of States associated to the track'>
        <arg type = 'const LHCb::State' name=' state' />
      </method>

      <method
        name    = 'removeFromStates'
        desc    = 'Remove a State from the list of states associated to the track'
        argList = 'LHCb::State* value'>
      </method>

      <method
        type    = 'void'
        name    = 'clearStates'
        desc    = 'Clear the State vector'>
      </method>

      <method
        type    = 'LHCb::State &amp;'
        name    = 'closestState'
        argList = 'double z'
        desc    = 'Retrieve the reference to the state closest to the given z-position' />

      <method
        type    = 'const LHCb::State &amp;'
        name    = 'closestState'
        argList = 'double z'
        desc    = 'Retrieve the reference to the state closest to the given z-position'
        const   = 'TRUE' />

      <method
        type    = 'LHCb::State &amp;'
        name    = 'closestState'
        argList = 'const Gaudi::Plane3D plane'
        desc    = 'Retrieve the reference to the state closest to the given plane' />

      <method
        type    = 'const LHCb::State &amp;'
        name    = 'closestState'
        argList = 'const Gaudi::Plane3D plane'
        desc    = 'Retrieve the reference to the state closest to the given plane'
        const   = 'TRUE' />

      <method
        type    = 'bool'
        name    = 'hasStateAt'
        argList = 'const LHCb::State::Location&amp; location'
        desc    = 'Check the existence of a state at a certain predefined location (see the Location enum in State.h)'
        const   = 'TRUE' />

      <method
        type    = 'LHCb::State &amp;'
        name    = 'stateAt'
        argList = 'const LHCb::State::Location&amp; location'
        desc    = 'Retrieve the state at a certain predefined location (see the Location enum in State.h)' />

      <method
        type    = 'const LHCb::State &amp;'
        name    = 'stateAt'
        argList = 'const LHCb::State::Location&amp; location'
        desc    = 'Retrieve the const state at a certain predefined location (see the Location enum in State.h)'
        const   = 'TRUE' />

      <method
        type    = 'unsigned int'
        name    = 'nLHCbIDs'
        desc    = 'Retrieve the number of LHCbIDs on the track'
        const   = 'TRUE'>
        <code>
  return m_lhcbIDs.size();
        </code>
      </method>

      <method
        type    = 'unsigned int'
        name    = 'nMeasurements'
        desc    = 'Retrieve the number of Measurements on the track'
        const   = 'TRUE'>
        <code>
  return m_measurements.size();
        </code>
      </method>

      <method
        name    = 'addToMeasurements'
        desc    = 'Add a Measurement to the list associated to the track'>
        <arg type = 'const LHCb::Measurement' name='meas' />
      </method>

     <method
        name    = 'removeFromMeasurements'
        desc    = 'Remove a Measurement from the list of Measurements associated to the track'
        argList = 'LHCb::Measurement* value'>
      </method>

      <method
        name    = 'addToNodes'
        desc    = 'Add a Node to the list of Nodes (note: track will take the ownership of this pointer!!)'>
        <arg type = 'Node*' name='node' />
        <code>
  m_nodes.push_back( node );
        </code>
      </method>

     <method
        name    = 'removeFromNodes'
        desc    = 'Remove a Node from the list of Nodes associated to the track'
        argList = 'Node* value'>
      </method>

     <method
        name    = 'addToLhcbIDs'
        desc    = 'Add an LHCbID to the list of LHCbIDs associated to the track'
        argList = 'LHCb::LHCbID value'>
        <code>
  if ( !isOnTrack( value ) ) m_lhcbIDs.push_back( value );
        </code>
      </method>

     <method
        name    = 'removeFromLhcbIDs'
        desc    = 'Remove an LHCbID from the list of LHCbIDs associated to the track'
        argList = 'LHCbID value' />

      <method
        name    = 'addToAncestors'
        desc    = 'Add a track to the list of ancestors of this track'>
        <arg type = 'const LHCb::Track ' name='ancestor' />
        <code>
  m_ancestors.push_back( (LHCb::Track*) &amp;ancestor );
        </code>
      </method>

      <method
        type    = 'void'
        name    = 'reset'
        desc    = 'Clear the track before re-use'
	virtual = 'TRUE'>
      </method>

      <method
        type    = 'LHCb::Track*'
        name    = 'cloneWithKey'
        desc    = 'Clone the track keeping the key (you take ownership of the pointer)'
	const   = 'TRUE'
        virtual = 'TRUE' />

      <method
        type    = 'LHCb::Track*'
        name    = 'clone'
        desc    = 'Clone the track (you take ownership of the pointer)'
	const   = 'TRUE'
        virtual = 'TRUE' />

      <method
        type    = 'void'
        name    = 'copy'
        argList = 'const LHCb::Track&amp; track'
        desc    = 'Copy the info from the argument track into this track'
	virtual = 'TRUE' />

      <method
        type    = 'bool'
        name    = 'checkType'
        argList = 'const LHCb::Track::Types&amp; value'
        desc    = 'Check the type of the track (see the Types enum)'
        const   = 'TRUE'>
        <code>
  return type() == value;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'checkHistory'
        argList = 'const LHCb::Track::History&amp; value'
        desc    = 'Check the history of the track (see the History enum)'
        const   = 'TRUE'>
        <code>
  return history() == value;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'checkFitHistory'
        argList = 'const LHCb::Track::FitHistory&amp; value'
        desc    = 'Check the fit history of the track (see the FitHistory enum)'
        const   = 'TRUE'>
        <code>
  return fitHistory() == value;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'checkPatRecStatus'
        argList = 'const LHCb::Track::PatRecStatus&amp; value'
        desc    = 'Check the pattern recognition status of the track (see the PatRecStatus enum)'
        const   = 'TRUE'>
        <code>
  return patRecStatus() == value;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'checkFitStatus'
        argList = 'const LHCb::Track::FitStatus&amp; value'
        desc    = 'Check the fitting status of the track (see the FitStatus enum)'
        const   = 'TRUE'>
        <code>
  return fitStatus() == value;
        </code>
      </method>

      <method
        name    = 'setFlag'
        argList = 'unsigned int flag, bool ok'
        desc    = 'Update the flag (see the Flags enum)'>
        <code>
  unsigned int val = (((unsigned int) flag) &lt;&lt; flagBits) &amp; flagMask;
  if (ok) m_flags |= val;
  else m_flags &amp;= ~val;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'checkFlag'
        argList = 'const LHCb::Track::Flags&amp; flag'
        desc    = 'Check the status of the flag (see the Flags enum)'
        const   = 'TRUE'>
        <code>
  unsigned int val = ((unsigned int) flag &lt;&lt; flagBits);  
  bool ok = (0 != ( m_flags &amp; flagMask &amp; val ));
  return ok;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'hasT'
        desc    = 'Check if track is of a type that goes thro T stations'
        const   = 'TRUE'>
        <code>
          bool hasTPart = false;
          if (type() == Track::Ttrack 
          || type() == Track::Downstream 
          || type() == Track::Long) hasTPart = true;
          return hasTPart;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'hasVelo'
        desc    = 'Check if track is of a type that goes thro Velo'
        const   = 'TRUE'>
        <code>
          bool hasVPart = false;
          if (type() == Track::Velo 
          || type() == Track::VeloR
          || type() == Track::Upstream 
          || type() == Track::Long) hasVPart = true;
          return hasVPart;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'hasTT'
        desc    = 'Check if track is of a type that goes thro TT'
        const   = 'TRUE'>
        <code>
          bool hasTTPart = false;
          if (type() == Track::Downstream 
          || type() == Track::Upstream 
          || type() == Track::Long) hasTTPart = true;
          return hasTTPart;
        </code>
      </method>


      <method
        type    = 'unsigned int'
        name    = 'nMeasurementsRemoved'
        desc    = 'Retrieve the number of Measurements removed by the track fit (the number of LHCbIDs remains unchanged)'
        const   = 'TRUE'>
        <code>
  return ( ( nMeasurements() > 0 ) ? ( nLHCbIDs() - nMeasurements() ) : 0 );
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'isOnTrack'
        argList = 'const LHCb::LHCbID value'
        desc    = 'Check whether the given LHCbID is on the track'
        const   = 'TRUE'>
      </method>

      <method
        type    = 'bool'
        name    = 'isOnTrack'
        argList = 'const LHCb::Measurement value'
        desc    = 'Check whether the given measurement is on the track'
        const   = 'TRUE'>
      </method>


      <method
        type    = 'bool'
        name    = 'isMeasurementOnTrack'
        argList = 'const LHCb::LHCbID value'
        desc    = 'Check whether the measurement on the track corresponding to the input LHCbID is present'
        const   = 'TRUE' />

      <method
        type    = 'const LHCb::Measurement&amp;'
        name    = 'measurement'
        argList = 'const LHCb::LHCbID value'
        desc    = 'Return the measurement on the track corresponding to the input LHCbID. Call first the "isMeasurementOnTrack" method before calling this one, as it throws an exception if the LHCbID is not present! (ONLY for tracking code, not for general use.)'
        const   = 'TRUE' />

      <method
        type    = 'LHCb::Measurement&amp;'
        name    = 'measurement'
        argList = 'const LHCb::LHCbID value'
	desc    = 'Return the measurement on the track corresponding to the input LHCbID. Call first the "isMeasurementOnTrack" method before calling this one, as it throws an exception if the LHCbID is not present! (ONLY for tracking code, not for general use.)' />
      
      <method
	name      = "fillStream"
	desc      = "printOut method to Gaudi message stream"
	type      = "std::ostream&amp;"
	virtual   = "TRUE"
	const     = "TRUE" >
	<arg name = "os" type = "std::ostream" inout = "BOTH"/>
      </method>

      <method
        name    = "hasInfo"
        const   = "TRUE"
        desc    = "Check whether the track has information for the specified key"
        argList = "const int key"
        type    = "bool" />

       <method
        name    = "addInfo"
        desc    = "Add new information, associated with the specified key. This method cannot be used to modify information for an already existing key"
        argList = "const int key, const double info"
        type    = "bool"
       />

       <method
        name    = "info"
        desc    = "Extract the information associated with the specified key. If there is no such information the default value will be returned."
        argList = "const int key, const double def"
        type    = "double"
        const   = "TRUE"
       />

       <method
        name    = "eraseInfo"
        desc    = "Erase the information associated with the specified key"
        argList = "const int key"
        type    = "Track::ExtraInfo::size_type"
       />

    </class>

  </package>
</gdd>
