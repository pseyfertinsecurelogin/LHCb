<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE gdd SYSTEM 'gdd.dtd'>
<gdd>
  <package name='TrackEvent'>

<!-- ==================== Node class definition ==================== -->

    <class
      name        = 'Node'
      author      = 'Jose Hernando, Eduardo Rodrigues'
      desc        = 'Node is a base class for classes linking track states to measurements.'
      serializers = 'FALSE'
      allocator   = 'NO' >

      <import name='gsl/gsl_math' />
      <import name='Event/State' />
      <import name='Event/Measurement' />
      <import name='Event/TrackParameters' />
      <import name='Event/TrackTypes' />

      &StlPtrVector;

      <enum
        name    = 'Type'
        value   = 'Unknown,HitOnTrack,Outlier,Reference'
        desc    = 'enumerator for the type of Node'
        access  = 'PUBLIC' />

      <constructor 
	desc     = "Constructor from a Measurement" 
	argList  = "LHCb::Measurement* meas"
	initList = "m_type(HitOnTrack),m_refIsSet(false), m_measurement(meas), m_residual(0.0), m_errResidual(0.0), m_errMeasure(0.0), m_projectionMatrix()">
        <code>
          m_refVector.setZ(meas->z()) ;
        </code>
      </constructor>

      <constructor 
	desc     = "Constructor from a z-position"
	argList  = "double z"
	initList = "m_type(Reference),m_refIsSet(false), m_measurement(0), m_residual(0.0), m_errResidual(0.0), m_errMeasure(0.0), m_projectionMatrix()">
        <code>
          m_refVector.setZ(z) ;
        </code>
      </constructor>
      
      <destructor virtual = 'TRUE' desc='destructer'>
        <code>
        </code>
      </destructor>
 
      <attribute
        type    = 'Type'
        name    = 'type'
        setMeth = 'TRUE'
        getMeth = 'TRUE'
        desc    = 'type of node' />

      <attribute
        type    = 'LHCb::State'
        name    = 'state'
        setMeth = 'TRUE'
        getMeth = 'TRUE'
        nonconstaccessor = 'TRUE'
        desc    = 'state' />

      <attribute
        type    = 'LHCb::StateVector'
        name    = 'refVector'
        desc    = 'the reference vector'
        setMeth = 'FALSE'
        getMeth = 'TRUE' />

      <attribute
        type    = 'bool'
        name    = 'refIsSet'
        desc    = 'flag for the reference vector'
        setMeth = 'FALSE' />

      <attribute
        type    = 'LHCb::Measurement*'
        name    = 'measurement'
        setMeth = 'FALSE'
        getMeth = 'FALSE'
        desc    = 'pointer to the measurement (not owner)' />

      <attribute
        type    = 'double'
        name    = 'residual'
        desc    = 'the residual value' />

      <attribute
        type    = 'double'
        name    = 'errResidual'
        desc    = 'the residual error'/>

      <attribute
        type    = 'double'
        name    = 'errMeasure'
        desc    = 'the measure error' />

      <attribute
        type    = 'Gaudi::TrackProjectionMatrix'
        name    = 'projectionMatrix'
        desc    = 'the projection matrix' />

      <method
        name    = 'setRefVector'
        desc    = 'Update the reference vector'
        argList = 'const Gaudi::TrackVector refVector'>
        <code>
  m_refIsSet  = true;
  m_refVector.parameters() = refVector;     
        </code>
      </method>

      <method
        name    = 'setRefVector'
        desc    = 'Update the reference vector'
        argList = 'const LHCb::StateVector refVector'>
        <code>
  m_refIsSet  = true;
  m_refVector = refVector;
        </code>
      </method>

      <method
        type    = 'double'
        name    = 'chi2'
        const   = 'TRUE'
        desc    = 'Retrieve the local chi^2 '>
        <code>
  if (    ( fabs(m_residual) > TrackParameters::lowTolerance)
       &amp;&amp; (m_errResidual > TrackParameters::lowTolerance)
     ) {
    return gsl_pow_2( m_residual/m_errResidual );
  }
  else {
    return 0.;
  }
        </code>
      </method>

      <method
        type    = 'LHCb::Measurement &amp;'
        name    = 'measurement'
        desc    = 'Retrieve the reference to the measurement'>
        <code>
  return *m_measurement;
        </code>
      </method>

      <method
        type    = 'LHCb::Measurement &amp;'
        name    = 'measurement'
        desc    = 'Retrieve const  the reference to the measurement'
        const   = 'TRUE'>
        <code>
  return *m_measurement;
        </code>
      </method>

      <method
        type    = 'void'
        name    = 'setMeasurement'
        desc    = 'Set the measurement' 
        const   = 'FALSE'>
        <arg type = 'LHCb::Measurement' name='meas' />
        <code> m_measurement = &amp;meas ; </code>
      </method>

      <method
        type    = 'LHCb::Node*'
        name    = 'clone'
        desc    = 'Clone the Node'
        const   = 'TRUE'
        virtual = 'TRUE'>
      </method>

      <method
	type    = 'double'
        name    = 'errResidual2'
	const   = 'TRUE'
        desc    = 'Return the error on the residual squared'>
        <code>
  return m_errResidual * m_errResidual;
        </code>
      </method>

      <method
	type    = 'double'
        name    = 'errMeasure2'
	const   = 'TRUE'
        desc    = 'Return the measure error squared'>
        <code>
  return m_errMeasure * m_errMeasure;
        </code>
      </method>

      <method
	type    = 'bool'
        name    = 'hasMeasurement'
	const   = 'TRUE'
        desc    = 'Return true if this Node has a valid pointer to measurement'>
        <code>
  return ( m_measurement != 0 );
        </code>
      </method>

      <method
        name    = 'removeMeasurement'
        desc    = 'Remove measurement from the node'>
        <code>
  m_measurement = 0;
  // for a node without measurement the chi2 = 0 ;-)
  m_residual    = 0.;
  m_errResidual = 0.;
  m_errMeasure  = 0.;
        </code>
      </method>

      <method
        type    = 'double'
        name    = 'z'
        const   = 'TRUE'
        desc    = 'z position of Node'>
        <code>
          return m_refVector.z() ;
        </code>
      </method>

      <method
        type    = 'Gaudi::XYZPoint'
        name    = 'position'
        const   = 'TRUE'
        desc    = 'Position of the State on the Node'>
        <code>
          return m_state.position() ;
        </code>
      </method>

    </class>

  </package>
</gdd>
