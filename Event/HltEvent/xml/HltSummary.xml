<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE gdd SYSTEM 'gdd.dtd'>
<gdd>
  <package name='HltEvent'>

<!-- HltSummary Class : Auxiliar Class-->

    <class
      name = "HltEnums"
      author      = 'Jose Hernando'
      desc = "Enumerations for the Hlt Summary classes">

      <import name="string" std="TRUE"/>

      <enum
        name   = 'HltDecisionType'
        desc   = 'Trigger type decision: muon, dimuon ,etc'
        strTypConv = 'TRUE'
        unknownValue = 'HltDecisionUnknown'
        value  = 'HltDecisionUnknown=0,
                  Decision=1,
	          Forced=2,
                  Muon=4,
	          DiMuon=8,
	          JPsi=16,
	          MuonHadron=32,
	          Hadron=64,
	          DiHadron=128,
	          Electron=256,
 	          DiElectron=512,
	          Gamma=1024,
                  Inclusive=2048,
	          Selections=4096,
	          Monitor=8192,
	          Calibration=16384'
        access = 'PUBLIC' />

     <method
	type = 'GaudiUtils::VectorMap &lt; std::string, LHCb::HltEnums::HltDecisionType &gt; &amp;'
	name = 'hltDecisionTypeTypMap'
	desc = 'gets map of enum and name. Useful for looping over all enums. Needs an instance of LHCb::HltEnums class.'
	const = 'TRUE' >
	<code>
  return s_HltDecisionTypeTypMap() ;
	</code>
     </method>

     <enum
        name   = 'HltAlley'
        desc   = 'Hlt alley'
        strTypConv = 'TRUE'
        unknownValue = 'AlleyUnknown'
        value  = 'AlleyUnknown=0,
	          MuonAlley,
	          MuonHadAlley,
	          HadronAlley,
                  CalAlley'
        access = 'PUBLIC' />

      <method
	type = 'GaudiUtils::VectorMap &lt; std::string, LHCb::HltEnums::HltAlley &gt; &amp;'
	name = 'hltAlleyTypMap'
	desc = 'gets map of enum and name. Useful for looping over all enums. Needs an instance of LHCb::HltEnums class.'
	const = 'TRUE' >
	<code>
  return s_HltAlleyTypMap() ;
	</code>
     </method>

     <enum
        name   = 'HltSelectionSummaryEnum'
        desc   = 'Hlt selection summary'
        strTypConv = 'TRUE'
        unknownValue = 'HltSelectionSummaryUnknown'
        value  = 'HltSelectionSummaryUnknown=0,
	          MuonEntry=100,
                  DiMuonEntry=101,
	          MuonL0Conf=102,
	          MuonPreTriggerSingle=104,
	          MuonPreTriggerDiMuon=106,
	          MuonPreTriggerIPDiMuon=108,
	          MuonTriggerSingle=110,
	          MuonTriggerDiMuon=112,
	          MuonTriggerIPDiMuon=114,
	          MuonPreTriggerPureDiMuon=116,
	          MuonPreTriggerPureIPDiMuon=118,
	          MuonTriggerPureDiMuon=120,
	          MuonTriggerPureIPDiMuon=122,
                  MuonHadEntry=200,
                  MuonHadL0Conf=202,
	          MuonHadPreTrigger=204,
                  MuonHadTrigger=206,
	          HadEntry=300,
                  HadL0Conf=302,
                  HadPreTriggerSingle=304,
                  HadPreTriggerDiHadron=306,
                  HadTrigger=308,
                  CalEntry=400,
                  CalL0Conf=402,
                  CalPreTrigger=404,
	          CalTrigger=406'
        access = 'PUBLIC' />

     <method
	type = 'GaudiUtils::VectorMap &lt; std::string, LHCb::HltEnums::HltSelectionSummaryEnum &gt; &amp;'
	name = 'hltSelectionSummaryEnumTypMap'
	desc = 'gets map of enum and name. Useful for looping over all enums. Needs an instance of LHCb::HltEnums class.'
	const = 'TRUE' >
	<code>
  return s_HltSelectionSummaryEnumTypMap() ;
	</code>
     </method>

      <enum
        name   = 'HltParticleInfo'
        desc   = 'Monitoring Quantities'
        strTypConv = 'TRUE'
        unknownValue = 'HltParticleInfoUnknown'
        value  = 'HltParticleInfoUnknown=0,
	rIP,
	IP,
	IPS,
	PT,
        PTVeloTT,
	Mass,
	DOCA,
	VertexChi2,
	VertexD,
	VertexDS,
	VertexRho,
	VertexDz,
	VertexPointing,
        VertexMinPT,
        VertexMaxPT,
	VertexIP,
	VertexIPS,
	Muon2DChi2,
	Muon3DChi2,
        Muon2DxDist,
        Muon3DxDist,
        Muon3DyDist,
        MuonTdist,
	CaloEt,
	Calo2DChi2,
	Calo3DChi2,
	MuonPt,
	MuonPID,
	CaloPID,
	RZVeloKey = 100,
	VeloKey = 101,
	VeloTTKey = 102,
	ForwardKey = 103,
	MuonKey =104,
	MuonTKey = 105,
	MuonVeloTKey = 106,
	MuonForwardKey = 107,
	MuonRefinedKey = 108,
	CaloKey = 109,
	CaloTKey = 110,
	CaloVeloTKey = 111,
	PVKey = 112,
        IDsFraction = 200,
	TrackFlagNoBackward = 201,   
	TrackFlagL0 = 202,   
        UserQuantity = 1000'
	access = ' PUBLIC' />	
     <method
	type = 'GaudiUtils::VectorMap &lt; std::string, LHCb::HltEnums::HltParticleInfo &gt; &amp;'
	name = 'hltParticleInfoTypMap'
	desc = 'gets map of enum and name. Useful for looping over all enums. Needs an instance of LHCb::HltEnums class.'
	const = 'TRUE' >
	<code>
  return s_HltParticleInfoTypMap() ;
	</code>
     </method>
    </class>
    
<!-- HltSelectionSummary Class -->

    <class
      name        = 'HltSelectionSummary'
      author      = 'Jose Hernando'
      desc        = 'Summary class for Hlt selections'>

      <import name='GaudiKernel/VectorMap' />
      <import name='Event/Particle' />
      <import name="vector" std="TRUE"/>

      <relation
        type      = 'LHCb::Particle'
        name      = 'particles'
        desc      = 'particle passing a trigger decision algorithm'
	setMeth   = 'FALSE'
        access    = 'PROTECTED'
	multiplicity = 'N' />

      <attribute
        type      = 'std::vector &lt; ContainedObject* &gt; '
        name      = 'data'
        desc      = 'data passing a trigger decision algorithm'
	setMeth   = 'FALSE'
        access    = 'PROTECTED' 
      />

      <attribute
        type      = 'bool'
        name      = 'decision'
        desc      = 'decision for this selection'
        />

      <attribute
        type      = 'std::string'
        name      = 'decisionType'
        desc      = 'decision type for this selection. See also IANNSvc.'
        />
      
      <method
	name    = 'setDecisionType'
	argList = 'std::string decisionType, bool ok'
	desc    = 'Update the decisionType and the decision'>
	<code>
setDecisionType(decisionType);
if (ok) setDecision(ok);
        </code>
      </method>

      <method
        name    = 'addParticle'
        desc    = 'Add a Particle to the list of saved Particle'>
        <arg type = 'const LHCb::Particle ' name='particle' />
        <code>
  m_particles.push_back( (LHCb::Particle*) &amp; particle );
        </code>
      </method>

      <method
        name    = 'addData'
        desc    = 'Add data to the list of saved Particle'>
        <arg type = 'const ContainedObject ' name='obj' />
        <code>
  m_data.push_back( (ContainedObject*) &amp; obj );
        </code>
      </method>

    </class>
    
<!-- HltSummary Class -->

    <class
      name        = 'HltSummary'
      author      = 'Jose Hernando'
      desc        = 'Summary class for Hlt'
      id          = '7510'>

      <location name="Default"   place="Hlt/Summary"/>
 
      <import name="vector" std="TRUE"/>
      <base name='DataObject' />
      &DataObject;

      <import name='GaudiKernel/GaudiException' />
      <import name="GaudiKernel/KeyedObject"/>
      <import name='GaudiKernel/VectorMap' />
      <import name='Event/HltSelectionSummary' />

      <attribute
        type = 'bitfield'
        name = 'pattern'
        desc = 'trigger pattern'
	init = '0'
	access = 'PUBLIC' >
	<bitfield
	  type = 'int'
	  name = 'decisionType'
	  length = '20'
	  desc = 'trigger decision type: muon, dimuon, etc'
	  setMeth = 'FALSE'
	  getMeth = 'FALSE'
	  checkMeth = 'FALSE' /> 
      </attribute>

      <attribute
        type = 'bitfield'
        name = 'patternError'
        desc = 'trigger pattern error'
	init = '0'
	access = 'PUBLIC' >
	<bitfield
	  type = 'int'
	  name = 'errorType'
	  length = '20'
	  desc = 'trigger error decision type: etc'
	  setMeth = 'FALSE'
	  getMeth = 'FALSE'
	  checkMeth = 'FALSE' /> 
      </attribute>

      <attribute
        type      = 'GaudiUtils::VectorMap&lt; std::string, LHCb::HltSelectionSummary &gt;'
        name      = 'selections'
        desc      = 'map of HltSelectionSummary es'
        access    = 'PROTECTED' />
      

      <method
	type = 'bool'
	name = 'decision'
	desc = 'returns the trigger decision'
	const = 'TRUE' >
	<code>
return checkDecisionType(1);
	</code>
      </method>

      <method
	name = 'setDecision'
	desc = 'returns the trigger decision'
	argList = 'bool decision' >
	<code>
setDecisionType(1,decision);
	</code>
      </method>
      
      <method
	name    = 'setDecisionType'
	argList = 'unsigned int decisionType, bool ok'
	desc    = 'Update the decisionType (see the DecisionTypes enum)'>
	<code>
unsigned int val = (((unsigned int) decisionType) &lt;&lt; decisionTypeBits) &amp; decisionTypeMask;
if (ok) m_pattern |= val;
else m_pattern &amp;= ~val;
if (ok &amp;&amp; decisionType != 1) setDecision(ok);
        </code>
      </method>

      <method
	type    = 'bool'
	name    = 'checkDecisionType'
        argList = 'unsigned int decisionType'
        desc    = 'Check the status of the decisionType (see the DecisionTypes enum)'
        const   = 'TRUE'>
        <code>
unsigned int val = ((unsigned int) decisionType &lt;&lt; decisionTypeBits);  
bool ok = (0 != ( m_pattern &amp; decisionTypeMask &amp; val ));
return ok;
        </code>
      </method>

  <method
	type = 'bool'
	name = 'error'
	desc = 'returns the trigger error'
	const = 'TRUE' >
	<code>
return checkErrorType(1);
	</code>
      </method>

      <method
	name = 'setError'
	desc = 'returns the trigger error'
	argList = 'bool error' >
	<code>
setErrorType(1,error);
	</code>
      </method>
      
      <method
	name    = 'setErrorType'
	argList = 'unsigned int errorType, bool ok'
	desc    = 'Update the errorType (see the ErrorTypes enum)'>
	<code>
unsigned int val = (((unsigned int) errorType) &lt;&lt; errorTypeBits) &amp; errorTypeMask;
if (ok) m_patternError |= val;
else m_patternError &amp;= ~val;
if (ok &amp;&amp; errorType != 1) setError(ok);
        </code>
      </method>

      <method
	type    = 'bool'
	name    = 'checkErrorType'
        argList = 'unsigned int errorType'
        desc    = 'Check the status of the errorType (see the ErrorTypes enum)'
        const   = 'TRUE'>
        <code>
unsigned int val = ((unsigned int) errorType &lt;&lt; errorTypeBits);  
bool ok = (0 != ( m_patternError &amp; errorTypeMask &amp; val ));
return ok;
        </code>
      </method>    

      <method
        type = 'bool'
        name = 'hasSelectionSummary'
        desc = 'has a summary from this trigger line?'
        argList = 'std::string selectionName'
        const = 'TRUE'>
        <code>
    return (m_selections.find(selectionName) != m_selections.end());
        </code>
      </method>

      <method
        type = 'const LHCb::HltSelectionSummary &amp;'
        name = 'selectionSummary'
        desc = 'return summary from this trigger selection'
        argList = 'std::string selectionName'
        const = 'TRUE' >
        <code>
   GaudiUtils::VectorMap&lt;std::string,LHCb::HltSelectionSummary&gt;::iterator it = m_selections.find(selectionName);  
   if ( it == m_selections.end() ) throw GaudiException( "No requested HltSelectionSummary in HltSummary","HltSummary",StatusCode::FAILURE );
   return it->second;
        </code>
      </method>
      
      <method
        type = 'LHCb::HltSelectionSummary &amp;'
        name = 'selectionSummary'
        desc = 'returns selection summary; if not in map, it will create it'
        argList = 'std::string selectionName'
        const = 'FALSE'>
        <code>
   GaudiUtils::VectorMap&lt;std::string,LHCb::HltSelectionSummary&gt;::iterator it = m_selections.find(selectionName);
   if (it == m_selections.end()) {
       LHCb::HltSelectionSummary summary;
       m_selections.insert(selectionName,summary);
       it = m_selections.find(selectionName);
   }
   return const_cast&lt; LHCb::HltSelectionSummary&amp; &gt;(it->second);
        </code>
      </method>

      <method
        type = 'std::vector &lt; std::string &gt;'
        name = 'selectionSummaryIDs'
        desc = 'return the selections names stored in the summary'
        const = 'TRUE' >
        <code>
    std::vector&lt;std::string&gt; names;
    GaudiUtils::VectorMap&lt;std::string,LHCb::HltSelectionSummary&gt;::iterator it = m_selections.begin();
    while ( it != m_selections.end()) names.push_back((it++)->first);
    return names;
        </code>
      </method>
      

    </class>

  </package>

</gdd>
